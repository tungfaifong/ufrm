// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: io.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_io_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_io_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "ioid.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_io_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_io_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_io_2eproto;
class IOAuthReq;
struct IOAuthReqDefaultTypeInternal;
extern IOAuthReqDefaultTypeInternal _IOAuthReq_default_instance_;
class IOAuthRsp;
struct IOAuthRspDefaultTypeInternal;
extern IOAuthRspDefaultTypeInternal _IOAuthRsp_default_instance_;
class IOPkg;
struct IOPkgDefaultTypeInternal;
extern IOPkgDefaultTypeInternal _IOPkg_default_instance_;
class IOPkgBody;
struct IOPkgBodyDefaultTypeInternal;
extern IOPkgBodyDefaultTypeInternal _IOPkgBody_default_instance_;
class IOPkgHead;
struct IOPkgHeadDefaultTypeInternal;
extern IOPkgHeadDefaultTypeInternal _IOPkgHead_default_instance_;
class IORegisterReq;
struct IORegisterReqDefaultTypeInternal;
extern IORegisterReqDefaultTypeInternal _IORegisterReq_default_instance_;
class IORegisterRsp;
struct IORegisterRspDefaultTypeInternal;
extern IORegisterRspDefaultTypeInternal _IORegisterRsp_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::IOAuthReq* Arena::CreateMaybeMessage<::IOAuthReq>(Arena*);
template<> ::IOAuthRsp* Arena::CreateMaybeMessage<::IOAuthRsp>(Arena*);
template<> ::IOPkg* Arena::CreateMaybeMessage<::IOPkg>(Arena*);
template<> ::IOPkgBody* Arena::CreateMaybeMessage<::IOPkgBody>(Arena*);
template<> ::IOPkgHead* Arena::CreateMaybeMessage<::IOPkgHead>(Arena*);
template<> ::IORegisterReq* Arena::CreateMaybeMessage<::IORegisterReq>(Arena*);
template<> ::IORegisterRsp* Arena::CreateMaybeMessage<::IORegisterRsp>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum IOAuthRsp_RESULT : int {
  IOAuthRsp_RESULT_SUCCESS = 0,
  IOAuthRsp_RESULT_IOAuthRsp_RESULT_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  IOAuthRsp_RESULT_IOAuthRsp_RESULT_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool IOAuthRsp_RESULT_IsValid(int value);
constexpr IOAuthRsp_RESULT IOAuthRsp_RESULT_RESULT_MIN = IOAuthRsp_RESULT_SUCCESS;
constexpr IOAuthRsp_RESULT IOAuthRsp_RESULT_RESULT_MAX = IOAuthRsp_RESULT_SUCCESS;
constexpr int IOAuthRsp_RESULT_RESULT_ARRAYSIZE = IOAuthRsp_RESULT_RESULT_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IOAuthRsp_RESULT_descriptor();
template<typename T>
inline const std::string& IOAuthRsp_RESULT_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IOAuthRsp_RESULT>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IOAuthRsp_RESULT_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IOAuthRsp_RESULT_descriptor(), enum_t_value);
}
inline bool IOAuthRsp_RESULT_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IOAuthRsp_RESULT* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IOAuthRsp_RESULT>(
    IOAuthRsp_RESULT_descriptor(), name, value);
}
// ===================================================================

class IORegisterReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:IORegisterReq) */ {
 public:
  inline IORegisterReq() : IORegisterReq(nullptr) {}
  explicit constexpr IORegisterReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IORegisterReq(const IORegisterReq& from);
  IORegisterReq(IORegisterReq&& from) noexcept
    : IORegisterReq() {
    *this = ::std::move(from);
  }

  inline IORegisterReq& operator=(const IORegisterReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline IORegisterReq& operator=(IORegisterReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IORegisterReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const IORegisterReq* internal_default_instance() {
    return reinterpret_cast<const IORegisterReq*>(
               &_IORegisterReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(IORegisterReq& a, IORegisterReq& b) {
    a.Swap(&b);
  }
  inline void Swap(IORegisterReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IORegisterReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IORegisterReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IORegisterReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const IORegisterReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const IORegisterReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IORegisterReq";
  }
  protected:
  explicit IORegisterReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:IORegisterReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_io_2eproto;
};
// -------------------------------------------------------------------

class IORegisterRsp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:IORegisterRsp) */ {
 public:
  inline IORegisterRsp() : IORegisterRsp(nullptr) {}
  explicit constexpr IORegisterRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IORegisterRsp(const IORegisterRsp& from);
  IORegisterRsp(IORegisterRsp&& from) noexcept
    : IORegisterRsp() {
    *this = ::std::move(from);
  }

  inline IORegisterRsp& operator=(const IORegisterRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline IORegisterRsp& operator=(IORegisterRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IORegisterRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const IORegisterRsp* internal_default_instance() {
    return reinterpret_cast<const IORegisterRsp*>(
               &_IORegisterRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(IORegisterRsp& a, IORegisterRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(IORegisterRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IORegisterRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IORegisterRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IORegisterRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const IORegisterRsp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const IORegisterRsp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IORegisterRsp";
  }
  protected:
  explicit IORegisterRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:IORegisterRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_io_2eproto;
};
// -------------------------------------------------------------------

class IOAuthReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IOAuthReq) */ {
 public:
  inline IOAuthReq() : IOAuthReq(nullptr) {}
  ~IOAuthReq() override;
  explicit constexpr IOAuthReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IOAuthReq(const IOAuthReq& from);
  IOAuthReq(IOAuthReq&& from) noexcept
    : IOAuthReq() {
    *this = ::std::move(from);
  }

  inline IOAuthReq& operator=(const IOAuthReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline IOAuthReq& operator=(IOAuthReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IOAuthReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const IOAuthReq* internal_default_instance() {
    return reinterpret_cast<const IOAuthReq*>(
               &_IOAuthReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(IOAuthReq& a, IOAuthReq& b) {
    a.Swap(&b);
  }
  inline void Swap(IOAuthReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IOAuthReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IOAuthReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IOAuthReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IOAuthReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IOAuthReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IOAuthReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IOAuthReq";
  }
  protected:
  explicit IOAuthReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleIdFieldNumber = 1,
    kGameIdFieldNumber = 2,
  };
  // uint32 role_id = 1;
  void clear_role_id();
  uint32_t role_id() const;
  void set_role_id(uint32_t value);
  private:
  uint32_t _internal_role_id() const;
  void _internal_set_role_id(uint32_t value);
  public:

  // uint32 game_id = 2;
  void clear_game_id();
  uint32_t game_id() const;
  void set_game_id(uint32_t value);
  private:
  uint32_t _internal_game_id() const;
  void _internal_set_game_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:IOAuthReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t role_id_;
  uint32_t game_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_io_2eproto;
};
// -------------------------------------------------------------------

class IOAuthRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IOAuthRsp) */ {
 public:
  inline IOAuthRsp() : IOAuthRsp(nullptr) {}
  ~IOAuthRsp() override;
  explicit constexpr IOAuthRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IOAuthRsp(const IOAuthRsp& from);
  IOAuthRsp(IOAuthRsp&& from) noexcept
    : IOAuthRsp() {
    *this = ::std::move(from);
  }

  inline IOAuthRsp& operator=(const IOAuthRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline IOAuthRsp& operator=(IOAuthRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IOAuthRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const IOAuthRsp* internal_default_instance() {
    return reinterpret_cast<const IOAuthRsp*>(
               &_IOAuthRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(IOAuthRsp& a, IOAuthRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(IOAuthRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IOAuthRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IOAuthRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IOAuthRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IOAuthRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IOAuthRsp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IOAuthRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IOAuthRsp";
  }
  protected:
  explicit IOAuthRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef IOAuthRsp_RESULT RESULT;
  static constexpr RESULT SUCCESS =
    IOAuthRsp_RESULT_SUCCESS;
  static inline bool RESULT_IsValid(int value) {
    return IOAuthRsp_RESULT_IsValid(value);
  }
  static constexpr RESULT RESULT_MIN =
    IOAuthRsp_RESULT_RESULT_MIN;
  static constexpr RESULT RESULT_MAX =
    IOAuthRsp_RESULT_RESULT_MAX;
  static constexpr int RESULT_ARRAYSIZE =
    IOAuthRsp_RESULT_RESULT_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RESULT_descriptor() {
    return IOAuthRsp_RESULT_descriptor();
  }
  template<typename T>
  static inline const std::string& RESULT_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RESULT>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RESULT_Name.");
    return IOAuthRsp_RESULT_Name(enum_t_value);
  }
  static inline bool RESULT_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RESULT* value) {
    return IOAuthRsp_RESULT_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .IOAuthRsp.RESULT result = 1;
  void clear_result();
  ::IOAuthRsp_RESULT result() const;
  void set_result(::IOAuthRsp_RESULT value);
  private:
  ::IOAuthRsp_RESULT _internal_result() const;
  void _internal_set_result(::IOAuthRsp_RESULT value);
  public:

  // @@protoc_insertion_point(class_scope:IOAuthRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_io_2eproto;
};
// -------------------------------------------------------------------

class IOPkgHead final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IOPkgHead) */ {
 public:
  inline IOPkgHead() : IOPkgHead(nullptr) {}
  ~IOPkgHead() override;
  explicit constexpr IOPkgHead(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IOPkgHead(const IOPkgHead& from);
  IOPkgHead(IOPkgHead&& from) noexcept
    : IOPkgHead() {
    *this = ::std::move(from);
  }

  inline IOPkgHead& operator=(const IOPkgHead& from) {
    CopyFrom(from);
    return *this;
  }
  inline IOPkgHead& operator=(IOPkgHead&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IOPkgHead& default_instance() {
    return *internal_default_instance();
  }
  static inline const IOPkgHead* internal_default_instance() {
    return reinterpret_cast<const IOPkgHead*>(
               &_IOPkgHead_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(IOPkgHead& a, IOPkgHead& b) {
    a.Swap(&b);
  }
  inline void Swap(IOPkgHead* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IOPkgHead* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IOPkgHead* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IOPkgHead>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IOPkgHead& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IOPkgHead& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IOPkgHead* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IOPkgHead";
  }
  protected:
  explicit IOPkgHead(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // .IOID id = 1;
  void clear_id();
  ::IOID id() const;
  void set_id(::IOID value);
  private:
  ::IOID _internal_id() const;
  void _internal_set_id(::IOID value);
  public:

  // @@protoc_insertion_point(class_scope:IOPkgHead)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_io_2eproto;
};
// -------------------------------------------------------------------

class IOPkgBody final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IOPkgBody) */ {
 public:
  inline IOPkgBody() : IOPkgBody(nullptr) {}
  ~IOPkgBody() override;
  explicit constexpr IOPkgBody(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IOPkgBody(const IOPkgBody& from);
  IOPkgBody(IOPkgBody&& from) noexcept
    : IOPkgBody() {
    *this = ::std::move(from);
  }

  inline IOPkgBody& operator=(const IOPkgBody& from) {
    CopyFrom(from);
    return *this;
  }
  inline IOPkgBody& operator=(IOPkgBody&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IOPkgBody& default_instance() {
    return *internal_default_instance();
  }
  enum BodyCase {
    kRegisterReq = 1,
    kRegisterRsp = 2,
    kAuthReq = 3,
    kAuthRsp = 4,
    BODY_NOT_SET = 0,
  };

  static inline const IOPkgBody* internal_default_instance() {
    return reinterpret_cast<const IOPkgBody*>(
               &_IOPkgBody_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(IOPkgBody& a, IOPkgBody& b) {
    a.Swap(&b);
  }
  inline void Swap(IOPkgBody* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IOPkgBody* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IOPkgBody* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IOPkgBody>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IOPkgBody& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IOPkgBody& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IOPkgBody* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IOPkgBody";
  }
  protected:
  explicit IOPkgBody(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegisterReqFieldNumber = 1,
    kRegisterRspFieldNumber = 2,
    kAuthReqFieldNumber = 3,
    kAuthRspFieldNumber = 4,
  };
  // .IORegisterReq register_req = 1;
  bool has_register_req() const;
  private:
  bool _internal_has_register_req() const;
  public:
  void clear_register_req();
  const ::IORegisterReq& register_req() const;
  PROTOBUF_NODISCARD ::IORegisterReq* release_register_req();
  ::IORegisterReq* mutable_register_req();
  void set_allocated_register_req(::IORegisterReq* register_req);
  private:
  const ::IORegisterReq& _internal_register_req() const;
  ::IORegisterReq* _internal_mutable_register_req();
  public:
  void unsafe_arena_set_allocated_register_req(
      ::IORegisterReq* register_req);
  ::IORegisterReq* unsafe_arena_release_register_req();

  // .IORegisterRsp register_rsp = 2;
  bool has_register_rsp() const;
  private:
  bool _internal_has_register_rsp() const;
  public:
  void clear_register_rsp();
  const ::IORegisterRsp& register_rsp() const;
  PROTOBUF_NODISCARD ::IORegisterRsp* release_register_rsp();
  ::IORegisterRsp* mutable_register_rsp();
  void set_allocated_register_rsp(::IORegisterRsp* register_rsp);
  private:
  const ::IORegisterRsp& _internal_register_rsp() const;
  ::IORegisterRsp* _internal_mutable_register_rsp();
  public:
  void unsafe_arena_set_allocated_register_rsp(
      ::IORegisterRsp* register_rsp);
  ::IORegisterRsp* unsafe_arena_release_register_rsp();

  // .IOAuthReq auth_req = 3;
  bool has_auth_req() const;
  private:
  bool _internal_has_auth_req() const;
  public:
  void clear_auth_req();
  const ::IOAuthReq& auth_req() const;
  PROTOBUF_NODISCARD ::IOAuthReq* release_auth_req();
  ::IOAuthReq* mutable_auth_req();
  void set_allocated_auth_req(::IOAuthReq* auth_req);
  private:
  const ::IOAuthReq& _internal_auth_req() const;
  ::IOAuthReq* _internal_mutable_auth_req();
  public:
  void unsafe_arena_set_allocated_auth_req(
      ::IOAuthReq* auth_req);
  ::IOAuthReq* unsafe_arena_release_auth_req();

  // .IOAuthRsp auth_rsp = 4;
  bool has_auth_rsp() const;
  private:
  bool _internal_has_auth_rsp() const;
  public:
  void clear_auth_rsp();
  const ::IOAuthRsp& auth_rsp() const;
  PROTOBUF_NODISCARD ::IOAuthRsp* release_auth_rsp();
  ::IOAuthRsp* mutable_auth_rsp();
  void set_allocated_auth_rsp(::IOAuthRsp* auth_rsp);
  private:
  const ::IOAuthRsp& _internal_auth_rsp() const;
  ::IOAuthRsp* _internal_mutable_auth_rsp();
  public:
  void unsafe_arena_set_allocated_auth_rsp(
      ::IOAuthRsp* auth_rsp);
  ::IOAuthRsp* unsafe_arena_release_auth_rsp();

  void clear_body();
  BodyCase body_case() const;
  // @@protoc_insertion_point(class_scope:IOPkgBody)
 private:
  class _Internal;
  void set_has_register_req();
  void set_has_register_rsp();
  void set_has_auth_req();
  void set_has_auth_rsp();

  inline bool has_body() const;
  inline void clear_has_body();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union BodyUnion {
    constexpr BodyUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::IORegisterReq* register_req_;
    ::IORegisterRsp* register_rsp_;
    ::IOAuthReq* auth_req_;
    ::IOAuthRsp* auth_rsp_;
  } body_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_io_2eproto;
};
// -------------------------------------------------------------------

class IOPkg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IOPkg) */ {
 public:
  inline IOPkg() : IOPkg(nullptr) {}
  ~IOPkg() override;
  explicit constexpr IOPkg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IOPkg(const IOPkg& from);
  IOPkg(IOPkg&& from) noexcept
    : IOPkg() {
    *this = ::std::move(from);
  }

  inline IOPkg& operator=(const IOPkg& from) {
    CopyFrom(from);
    return *this;
  }
  inline IOPkg& operator=(IOPkg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IOPkg& default_instance() {
    return *internal_default_instance();
  }
  static inline const IOPkg* internal_default_instance() {
    return reinterpret_cast<const IOPkg*>(
               &_IOPkg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(IOPkg& a, IOPkg& b) {
    a.Swap(&b);
  }
  inline void Swap(IOPkg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IOPkg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IOPkg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IOPkg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IOPkg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IOPkg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IOPkg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IOPkg";
  }
  protected:
  explicit IOPkg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeadFieldNumber = 1,
    kBodyFieldNumber = 2,
  };
  // .IOPkgHead head = 1;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::IOPkgHead& head() const;
  PROTOBUF_NODISCARD ::IOPkgHead* release_head();
  ::IOPkgHead* mutable_head();
  void set_allocated_head(::IOPkgHead* head);
  private:
  const ::IOPkgHead& _internal_head() const;
  ::IOPkgHead* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::IOPkgHead* head);
  ::IOPkgHead* unsafe_arena_release_head();

  // .IOPkgBody body = 2;
  bool has_body() const;
  private:
  bool _internal_has_body() const;
  public:
  void clear_body();
  const ::IOPkgBody& body() const;
  PROTOBUF_NODISCARD ::IOPkgBody* release_body();
  ::IOPkgBody* mutable_body();
  void set_allocated_body(::IOPkgBody* body);
  private:
  const ::IOPkgBody& _internal_body() const;
  ::IOPkgBody* _internal_mutable_body();
  public:
  void unsafe_arena_set_allocated_body(
      ::IOPkgBody* body);
  ::IOPkgBody* unsafe_arena_release_body();

  // @@protoc_insertion_point(class_scope:IOPkg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::IOPkgHead* head_;
  ::IOPkgBody* body_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_io_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// IORegisterReq

// -------------------------------------------------------------------

// IORegisterRsp

// -------------------------------------------------------------------

// IOAuthReq

// uint32 role_id = 1;
inline void IOAuthReq::clear_role_id() {
  role_id_ = 0u;
}
inline uint32_t IOAuthReq::_internal_role_id() const {
  return role_id_;
}
inline uint32_t IOAuthReq::role_id() const {
  // @@protoc_insertion_point(field_get:IOAuthReq.role_id)
  return _internal_role_id();
}
inline void IOAuthReq::_internal_set_role_id(uint32_t value) {
  
  role_id_ = value;
}
inline void IOAuthReq::set_role_id(uint32_t value) {
  _internal_set_role_id(value);
  // @@protoc_insertion_point(field_set:IOAuthReq.role_id)
}

// uint32 game_id = 2;
inline void IOAuthReq::clear_game_id() {
  game_id_ = 0u;
}
inline uint32_t IOAuthReq::_internal_game_id() const {
  return game_id_;
}
inline uint32_t IOAuthReq::game_id() const {
  // @@protoc_insertion_point(field_get:IOAuthReq.game_id)
  return _internal_game_id();
}
inline void IOAuthReq::_internal_set_game_id(uint32_t value) {
  
  game_id_ = value;
}
inline void IOAuthReq::set_game_id(uint32_t value) {
  _internal_set_game_id(value);
  // @@protoc_insertion_point(field_set:IOAuthReq.game_id)
}

// -------------------------------------------------------------------

// IOAuthRsp

// .IOAuthRsp.RESULT result = 1;
inline void IOAuthRsp::clear_result() {
  result_ = 0;
}
inline ::IOAuthRsp_RESULT IOAuthRsp::_internal_result() const {
  return static_cast< ::IOAuthRsp_RESULT >(result_);
}
inline ::IOAuthRsp_RESULT IOAuthRsp::result() const {
  // @@protoc_insertion_point(field_get:IOAuthRsp.result)
  return _internal_result();
}
inline void IOAuthRsp::_internal_set_result(::IOAuthRsp_RESULT value) {
  
  result_ = value;
}
inline void IOAuthRsp::set_result(::IOAuthRsp_RESULT value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:IOAuthRsp.result)
}

// -------------------------------------------------------------------

// IOPkgHead

// .IOID id = 1;
inline void IOPkgHead::clear_id() {
  id_ = 0;
}
inline ::IOID IOPkgHead::_internal_id() const {
  return static_cast< ::IOID >(id_);
}
inline ::IOID IOPkgHead::id() const {
  // @@protoc_insertion_point(field_get:IOPkgHead.id)
  return _internal_id();
}
inline void IOPkgHead::_internal_set_id(::IOID value) {
  
  id_ = value;
}
inline void IOPkgHead::set_id(::IOID value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:IOPkgHead.id)
}

// -------------------------------------------------------------------

// IOPkgBody

// .IORegisterReq register_req = 1;
inline bool IOPkgBody::_internal_has_register_req() const {
  return body_case() == kRegisterReq;
}
inline bool IOPkgBody::has_register_req() const {
  return _internal_has_register_req();
}
inline void IOPkgBody::set_has_register_req() {
  _oneof_case_[0] = kRegisterReq;
}
inline void IOPkgBody::clear_register_req() {
  if (_internal_has_register_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete body_.register_req_;
    }
    clear_has_body();
  }
}
inline ::IORegisterReq* IOPkgBody::release_register_req() {
  // @@protoc_insertion_point(field_release:IOPkgBody.register_req)
  if (_internal_has_register_req()) {
    clear_has_body();
      ::IORegisterReq* temp = body_.register_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    body_.register_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::IORegisterReq& IOPkgBody::_internal_register_req() const {
  return _internal_has_register_req()
      ? *body_.register_req_
      : reinterpret_cast< ::IORegisterReq&>(::_IORegisterReq_default_instance_);
}
inline const ::IORegisterReq& IOPkgBody::register_req() const {
  // @@protoc_insertion_point(field_get:IOPkgBody.register_req)
  return _internal_register_req();
}
inline ::IORegisterReq* IOPkgBody::unsafe_arena_release_register_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:IOPkgBody.register_req)
  if (_internal_has_register_req()) {
    clear_has_body();
    ::IORegisterReq* temp = body_.register_req_;
    body_.register_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void IOPkgBody::unsafe_arena_set_allocated_register_req(::IORegisterReq* register_req) {
  clear_body();
  if (register_req) {
    set_has_register_req();
    body_.register_req_ = register_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IOPkgBody.register_req)
}
inline ::IORegisterReq* IOPkgBody::_internal_mutable_register_req() {
  if (!_internal_has_register_req()) {
    clear_body();
    set_has_register_req();
    body_.register_req_ = CreateMaybeMessage< ::IORegisterReq >(GetArenaForAllocation());
  }
  return body_.register_req_;
}
inline ::IORegisterReq* IOPkgBody::mutable_register_req() {
  ::IORegisterReq* _msg = _internal_mutable_register_req();
  // @@protoc_insertion_point(field_mutable:IOPkgBody.register_req)
  return _msg;
}

// .IORegisterRsp register_rsp = 2;
inline bool IOPkgBody::_internal_has_register_rsp() const {
  return body_case() == kRegisterRsp;
}
inline bool IOPkgBody::has_register_rsp() const {
  return _internal_has_register_rsp();
}
inline void IOPkgBody::set_has_register_rsp() {
  _oneof_case_[0] = kRegisterRsp;
}
inline void IOPkgBody::clear_register_rsp() {
  if (_internal_has_register_rsp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete body_.register_rsp_;
    }
    clear_has_body();
  }
}
inline ::IORegisterRsp* IOPkgBody::release_register_rsp() {
  // @@protoc_insertion_point(field_release:IOPkgBody.register_rsp)
  if (_internal_has_register_rsp()) {
    clear_has_body();
      ::IORegisterRsp* temp = body_.register_rsp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    body_.register_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::IORegisterRsp& IOPkgBody::_internal_register_rsp() const {
  return _internal_has_register_rsp()
      ? *body_.register_rsp_
      : reinterpret_cast< ::IORegisterRsp&>(::_IORegisterRsp_default_instance_);
}
inline const ::IORegisterRsp& IOPkgBody::register_rsp() const {
  // @@protoc_insertion_point(field_get:IOPkgBody.register_rsp)
  return _internal_register_rsp();
}
inline ::IORegisterRsp* IOPkgBody::unsafe_arena_release_register_rsp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:IOPkgBody.register_rsp)
  if (_internal_has_register_rsp()) {
    clear_has_body();
    ::IORegisterRsp* temp = body_.register_rsp_;
    body_.register_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void IOPkgBody::unsafe_arena_set_allocated_register_rsp(::IORegisterRsp* register_rsp) {
  clear_body();
  if (register_rsp) {
    set_has_register_rsp();
    body_.register_rsp_ = register_rsp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IOPkgBody.register_rsp)
}
inline ::IORegisterRsp* IOPkgBody::_internal_mutable_register_rsp() {
  if (!_internal_has_register_rsp()) {
    clear_body();
    set_has_register_rsp();
    body_.register_rsp_ = CreateMaybeMessage< ::IORegisterRsp >(GetArenaForAllocation());
  }
  return body_.register_rsp_;
}
inline ::IORegisterRsp* IOPkgBody::mutable_register_rsp() {
  ::IORegisterRsp* _msg = _internal_mutable_register_rsp();
  // @@protoc_insertion_point(field_mutable:IOPkgBody.register_rsp)
  return _msg;
}

// .IOAuthReq auth_req = 3;
inline bool IOPkgBody::_internal_has_auth_req() const {
  return body_case() == kAuthReq;
}
inline bool IOPkgBody::has_auth_req() const {
  return _internal_has_auth_req();
}
inline void IOPkgBody::set_has_auth_req() {
  _oneof_case_[0] = kAuthReq;
}
inline void IOPkgBody::clear_auth_req() {
  if (_internal_has_auth_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete body_.auth_req_;
    }
    clear_has_body();
  }
}
inline ::IOAuthReq* IOPkgBody::release_auth_req() {
  // @@protoc_insertion_point(field_release:IOPkgBody.auth_req)
  if (_internal_has_auth_req()) {
    clear_has_body();
      ::IOAuthReq* temp = body_.auth_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    body_.auth_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::IOAuthReq& IOPkgBody::_internal_auth_req() const {
  return _internal_has_auth_req()
      ? *body_.auth_req_
      : reinterpret_cast< ::IOAuthReq&>(::_IOAuthReq_default_instance_);
}
inline const ::IOAuthReq& IOPkgBody::auth_req() const {
  // @@protoc_insertion_point(field_get:IOPkgBody.auth_req)
  return _internal_auth_req();
}
inline ::IOAuthReq* IOPkgBody::unsafe_arena_release_auth_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:IOPkgBody.auth_req)
  if (_internal_has_auth_req()) {
    clear_has_body();
    ::IOAuthReq* temp = body_.auth_req_;
    body_.auth_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void IOPkgBody::unsafe_arena_set_allocated_auth_req(::IOAuthReq* auth_req) {
  clear_body();
  if (auth_req) {
    set_has_auth_req();
    body_.auth_req_ = auth_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IOPkgBody.auth_req)
}
inline ::IOAuthReq* IOPkgBody::_internal_mutable_auth_req() {
  if (!_internal_has_auth_req()) {
    clear_body();
    set_has_auth_req();
    body_.auth_req_ = CreateMaybeMessage< ::IOAuthReq >(GetArenaForAllocation());
  }
  return body_.auth_req_;
}
inline ::IOAuthReq* IOPkgBody::mutable_auth_req() {
  ::IOAuthReq* _msg = _internal_mutable_auth_req();
  // @@protoc_insertion_point(field_mutable:IOPkgBody.auth_req)
  return _msg;
}

// .IOAuthRsp auth_rsp = 4;
inline bool IOPkgBody::_internal_has_auth_rsp() const {
  return body_case() == kAuthRsp;
}
inline bool IOPkgBody::has_auth_rsp() const {
  return _internal_has_auth_rsp();
}
inline void IOPkgBody::set_has_auth_rsp() {
  _oneof_case_[0] = kAuthRsp;
}
inline void IOPkgBody::clear_auth_rsp() {
  if (_internal_has_auth_rsp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete body_.auth_rsp_;
    }
    clear_has_body();
  }
}
inline ::IOAuthRsp* IOPkgBody::release_auth_rsp() {
  // @@protoc_insertion_point(field_release:IOPkgBody.auth_rsp)
  if (_internal_has_auth_rsp()) {
    clear_has_body();
      ::IOAuthRsp* temp = body_.auth_rsp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    body_.auth_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::IOAuthRsp& IOPkgBody::_internal_auth_rsp() const {
  return _internal_has_auth_rsp()
      ? *body_.auth_rsp_
      : reinterpret_cast< ::IOAuthRsp&>(::_IOAuthRsp_default_instance_);
}
inline const ::IOAuthRsp& IOPkgBody::auth_rsp() const {
  // @@protoc_insertion_point(field_get:IOPkgBody.auth_rsp)
  return _internal_auth_rsp();
}
inline ::IOAuthRsp* IOPkgBody::unsafe_arena_release_auth_rsp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:IOPkgBody.auth_rsp)
  if (_internal_has_auth_rsp()) {
    clear_has_body();
    ::IOAuthRsp* temp = body_.auth_rsp_;
    body_.auth_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void IOPkgBody::unsafe_arena_set_allocated_auth_rsp(::IOAuthRsp* auth_rsp) {
  clear_body();
  if (auth_rsp) {
    set_has_auth_rsp();
    body_.auth_rsp_ = auth_rsp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IOPkgBody.auth_rsp)
}
inline ::IOAuthRsp* IOPkgBody::_internal_mutable_auth_rsp() {
  if (!_internal_has_auth_rsp()) {
    clear_body();
    set_has_auth_rsp();
    body_.auth_rsp_ = CreateMaybeMessage< ::IOAuthRsp >(GetArenaForAllocation());
  }
  return body_.auth_rsp_;
}
inline ::IOAuthRsp* IOPkgBody::mutable_auth_rsp() {
  ::IOAuthRsp* _msg = _internal_mutable_auth_rsp();
  // @@protoc_insertion_point(field_mutable:IOPkgBody.auth_rsp)
  return _msg;
}

inline bool IOPkgBody::has_body() const {
  return body_case() != BODY_NOT_SET;
}
inline void IOPkgBody::clear_has_body() {
  _oneof_case_[0] = BODY_NOT_SET;
}
inline IOPkgBody::BodyCase IOPkgBody::body_case() const {
  return IOPkgBody::BodyCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// IOPkg

// .IOPkgHead head = 1;
inline bool IOPkg::_internal_has_head() const {
  return this != internal_default_instance() && head_ != nullptr;
}
inline bool IOPkg::has_head() const {
  return _internal_has_head();
}
inline void IOPkg::clear_head() {
  if (GetArenaForAllocation() == nullptr && head_ != nullptr) {
    delete head_;
  }
  head_ = nullptr;
}
inline const ::IOPkgHead& IOPkg::_internal_head() const {
  const ::IOPkgHead* p = head_;
  return p != nullptr ? *p : reinterpret_cast<const ::IOPkgHead&>(
      ::_IOPkgHead_default_instance_);
}
inline const ::IOPkgHead& IOPkg::head() const {
  // @@protoc_insertion_point(field_get:IOPkg.head)
  return _internal_head();
}
inline void IOPkg::unsafe_arena_set_allocated_head(
    ::IOPkgHead* head) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(head_);
  }
  head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IOPkg.head)
}
inline ::IOPkgHead* IOPkg::release_head() {
  
  ::IOPkgHead* temp = head_;
  head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::IOPkgHead* IOPkg::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:IOPkg.head)
  
  ::IOPkgHead* temp = head_;
  head_ = nullptr;
  return temp;
}
inline ::IOPkgHead* IOPkg::_internal_mutable_head() {
  
  if (head_ == nullptr) {
    auto* p = CreateMaybeMessage<::IOPkgHead>(GetArenaForAllocation());
    head_ = p;
  }
  return head_;
}
inline ::IOPkgHead* IOPkg::mutable_head() {
  ::IOPkgHead* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:IOPkg.head)
  return _msg;
}
inline void IOPkg::set_allocated_head(::IOPkgHead* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::IOPkgHead>::GetOwningArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  head_ = head;
  // @@protoc_insertion_point(field_set_allocated:IOPkg.head)
}

// .IOPkgBody body = 2;
inline bool IOPkg::_internal_has_body() const {
  return this != internal_default_instance() && body_ != nullptr;
}
inline bool IOPkg::has_body() const {
  return _internal_has_body();
}
inline void IOPkg::clear_body() {
  if (GetArenaForAllocation() == nullptr && body_ != nullptr) {
    delete body_;
  }
  body_ = nullptr;
}
inline const ::IOPkgBody& IOPkg::_internal_body() const {
  const ::IOPkgBody* p = body_;
  return p != nullptr ? *p : reinterpret_cast<const ::IOPkgBody&>(
      ::_IOPkgBody_default_instance_);
}
inline const ::IOPkgBody& IOPkg::body() const {
  // @@protoc_insertion_point(field_get:IOPkg.body)
  return _internal_body();
}
inline void IOPkg::unsafe_arena_set_allocated_body(
    ::IOPkgBody* body) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(body_);
  }
  body_ = body;
  if (body) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IOPkg.body)
}
inline ::IOPkgBody* IOPkg::release_body() {
  
  ::IOPkgBody* temp = body_;
  body_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::IOPkgBody* IOPkg::unsafe_arena_release_body() {
  // @@protoc_insertion_point(field_release:IOPkg.body)
  
  ::IOPkgBody* temp = body_;
  body_ = nullptr;
  return temp;
}
inline ::IOPkgBody* IOPkg::_internal_mutable_body() {
  
  if (body_ == nullptr) {
    auto* p = CreateMaybeMessage<::IOPkgBody>(GetArenaForAllocation());
    body_ = p;
  }
  return body_;
}
inline ::IOPkgBody* IOPkg::mutable_body() {
  ::IOPkgBody* _msg = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:IOPkg.body)
  return _msg;
}
inline void IOPkg::set_allocated_body(::IOPkgBody* body) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete body_;
  }
  if (body) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::IOPkgBody>::GetOwningArena(body);
    if (message_arena != submessage_arena) {
      body = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body, submessage_arena);
    }
    
  } else {
    
  }
  body_ = body;
  // @@protoc_insertion_point(field_set_allocated:IOPkg.body)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::IOAuthRsp_RESULT> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IOAuthRsp_RESULT>() {
  return ::IOAuthRsp_RESULT_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_io_2eproto
