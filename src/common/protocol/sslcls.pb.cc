// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sslcls.proto

#include "sslcls.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
constexpr SSLCLSNode::SSLCLSNode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ip_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , node_type_(0)

  , node_id_(0u)
  , port_(0u){}
struct SSLCLSNodeDefaultTypeInternal {
  constexpr SSLCLSNodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SSLCLSNodeDefaultTypeInternal() {}
  union {
    SSLCLSNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SSLCLSNodeDefaultTypeInternal _SSLCLSNode_default_instance_;
constexpr SSLCLSNodeRegister::SSLCLSNodeRegister(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : node_(nullptr){}
struct SSLCLSNodeRegisterDefaultTypeInternal {
  constexpr SSLCLSNodeRegisterDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SSLCLSNodeRegisterDefaultTypeInternal() {}
  union {
    SSLCLSNodeRegister _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SSLCLSNodeRegisterDefaultTypeInternal _SSLCLSNodeRegister_default_instance_;
constexpr SSLCLSNodeUnregister::SSLCLSNodeUnregister(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : node_type_(0)

  , node_id_(0u){}
struct SSLCLSNodeUnregisterDefaultTypeInternal {
  constexpr SSLCLSNodeUnregisterDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SSLCLSNodeUnregisterDefaultTypeInternal() {}
  union {
    SSLCLSNodeUnregister _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SSLCLSNodeUnregisterDefaultTypeInternal _SSLCLSNodeUnregister_default_instance_;
constexpr SSLCLSHeartBeatReq::SSLCLSHeartBeatReq(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : load_(0u){}
struct SSLCLSHeartBeatReqDefaultTypeInternal {
  constexpr SSLCLSHeartBeatReqDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SSLCLSHeartBeatReqDefaultTypeInternal() {}
  union {
    SSLCLSHeartBeatReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SSLCLSHeartBeatReqDefaultTypeInternal _SSLCLSHeartBeatReq_default_instance_;
constexpr SSLSLCHeartBeatRsp::SSLSLCHeartBeatRsp(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct SSLSLCHeartBeatRspDefaultTypeInternal {
  constexpr SSLSLCHeartBeatRspDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SSLSLCHeartBeatRspDefaultTypeInternal() {}
  union {
    SSLSLCHeartBeatRsp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SSLSLCHeartBeatRspDefaultTypeInternal _SSLSLCHeartBeatRsp_default_instance_;
constexpr SSLCLSSubscribe::SSLCLSSubscribe(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : node_type_(0)
{}
struct SSLCLSSubscribeDefaultTypeInternal {
  constexpr SSLCLSSubscribeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SSLCLSSubscribeDefaultTypeInternal() {}
  union {
    SSLCLSSubscribe _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SSLCLSSubscribeDefaultTypeInternal _SSLCLSSubscribe_default_instance_;
constexpr SSLSLCPublish::SSLSLCPublish(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : node_(nullptr)
  , publish_type_(0)
{}
struct SSLSLCPublishDefaultTypeInternal {
  constexpr SSLSLCPublishDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SSLSLCPublishDefaultTypeInternal() {}
  union {
    SSLSLCPublish _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SSLSLCPublishDefaultTypeInternal _SSLSLCPublish_default_instance_;
constexpr SSLCLSGetAllNodesReq::SSLCLSGetAllNodesReq(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : node_type_(0)
{}
struct SSLCLSGetAllNodesReqDefaultTypeInternal {
  constexpr SSLCLSGetAllNodesReqDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SSLCLSGetAllNodesReqDefaultTypeInternal() {}
  union {
    SSLCLSGetAllNodesReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SSLCLSGetAllNodesReqDefaultTypeInternal _SSLCLSGetAllNodesReq_default_instance_;
constexpr SSLSLCGetAllNodesRsp::SSLSLCGetAllNodesRsp(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : nodes_(){}
struct SSLSLCGetAllNodesRspDefaultTypeInternal {
  constexpr SSLSLCGetAllNodesRspDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SSLSLCGetAllNodesRspDefaultTypeInternal() {}
  union {
    SSLSLCGetAllNodesRsp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SSLSLCGetAllNodesRspDefaultTypeInternal _SSLSLCGetAllNodesRsp_default_instance_;
constexpr SSLCLSGetLeastLoadNodeReq::SSLCLSGetLeastLoadNodeReq(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : node_type_(0)
{}
struct SSLCLSGetLeastLoadNodeReqDefaultTypeInternal {
  constexpr SSLCLSGetLeastLoadNodeReqDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SSLCLSGetLeastLoadNodeReqDefaultTypeInternal() {}
  union {
    SSLCLSGetLeastLoadNodeReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SSLCLSGetLeastLoadNodeReqDefaultTypeInternal _SSLCLSGetLeastLoadNodeReq_default_instance_;
constexpr SSLSLCGetLeastLoadNodeRsp::SSLSLCGetLeastLoadNodeRsp(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : node_(nullptr){}
struct SSLSLCGetLeastLoadNodeRspDefaultTypeInternal {
  constexpr SSLSLCGetLeastLoadNodeRspDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SSLSLCGetLeastLoadNodeRspDefaultTypeInternal() {}
  union {
    SSLSLCGetLeastLoadNodeRsp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SSLSLCGetLeastLoadNodeRspDefaultTypeInternal _SSLSLCGetLeastLoadNodeRsp_default_instance_;
constexpr SSLCLSPkgBody::SSLCLSPkgBody(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct SSLCLSPkgBodyDefaultTypeInternal {
  constexpr SSLCLSPkgBodyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SSLCLSPkgBodyDefaultTypeInternal() {}
  union {
    SSLCLSPkgBody _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SSLCLSPkgBodyDefaultTypeInternal _SSLCLSPkgBody_default_instance_;
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_sslcls_2eproto[12];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_sslcls_2eproto[1];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_sslcls_2eproto = nullptr;

const uint32_t TableStruct_sslcls_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SSLCLSNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SSLCLSNode, node_type_),
  PROTOBUF_FIELD_OFFSET(::SSLCLSNode, node_id_),
  PROTOBUF_FIELD_OFFSET(::SSLCLSNode, ip_),
  PROTOBUF_FIELD_OFFSET(::SSLCLSNode, port_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SSLCLSNodeRegister, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SSLCLSNodeRegister, node_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SSLCLSNodeUnregister, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SSLCLSNodeUnregister, node_type_),
  PROTOBUF_FIELD_OFFSET(::SSLCLSNodeUnregister, node_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SSLCLSHeartBeatReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SSLCLSHeartBeatReq, load_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SSLSLCHeartBeatRsp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SSLCLSSubscribe, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SSLCLSSubscribe, node_type_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SSLSLCPublish, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SSLSLCPublish, publish_type_),
  PROTOBUF_FIELD_OFFSET(::SSLSLCPublish, node_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SSLCLSGetAllNodesReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SSLCLSGetAllNodesReq, node_type_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SSLSLCGetAllNodesRsp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SSLSLCGetAllNodesRsp, nodes_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SSLCLSGetLeastLoadNodeReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SSLCLSGetLeastLoadNodeReq, node_type_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SSLSLCGetLeastLoadNodeRsp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SSLSLCGetLeastLoadNodeRsp, node_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SSLCLSPkgBody, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::SSLCLSPkgBody, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::SSLCLSPkgBody, body_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::SSLCLSNode)},
  { 10, -1, -1, sizeof(::SSLCLSNodeRegister)},
  { 17, -1, -1, sizeof(::SSLCLSNodeUnregister)},
  { 25, -1, -1, sizeof(::SSLCLSHeartBeatReq)},
  { 32, -1, -1, sizeof(::SSLSLCHeartBeatRsp)},
  { 38, -1, -1, sizeof(::SSLCLSSubscribe)},
  { 45, -1, -1, sizeof(::SSLSLCPublish)},
  { 53, -1, -1, sizeof(::SSLCLSGetAllNodesReq)},
  { 60, -1, -1, sizeof(::SSLSLCGetAllNodesRsp)},
  { 67, -1, -1, sizeof(::SSLCLSGetLeastLoadNodeReq)},
  { 74, -1, -1, sizeof(::SSLSLCGetLeastLoadNodeRsp)},
  { 81, -1, -1, sizeof(::SSLCLSPkgBody)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_SSLCLSNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_SSLCLSNodeRegister_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_SSLCLSNodeUnregister_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_SSLCLSHeartBeatReq_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_SSLSLCHeartBeatRsp_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_SSLCLSSubscribe_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_SSLSLCPublish_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_SSLCLSGetAllNodesReq_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_SSLSLCGetAllNodesRsp_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_SSLCLSGetLeastLoadNodeReq_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_SSLSLCGetLeastLoadNodeRsp_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_SSLCLSPkgBody_default_instance_),
};

const char descriptor_table_protodef_sslcls_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\014sslcls.proto\032\014common.proto\"U\n\nSSLCLSNo"
  "de\022\034\n\tnode_type\030\001 \001(\0162\t.NODETYPE\022\017\n\007node"
  "_id\030\002 \001(\r\022\n\n\002ip\030\003 \001(\t\022\014\n\004port\030\004 \001(\r\"/\n\022S"
  "SLCLSNodeRegister\022\031\n\004node\030\001 \001(\0132\013.SSLCLS"
  "Node\"E\n\024SSLCLSNodeUnregister\022\034\n\tnode_typ"
  "e\030\001 \001(\0162\t.NODETYPE\022\017\n\007node_id\030\002 \001(\r\"\"\n\022S"
  "SLCLSHeartBeatReq\022\014\n\004load\030\001 \001(\r\"\024\n\022SSLSL"
  "CHeartBeatRsp\"/\n\017SSLCLSSubscribe\022\034\n\tnode"
  "_type\030\001 \001(\0162\t.NODETYPE\"\225\001\n\rSSLSLCPublish"
  "\0220\n\014publish_type\030\001 \001(\0162\032.SSLSLCPublish.P"
  "UBLISHTYPE\022\031\n\004node\030\002 \001(\0132\013.SSLCLSNode\"7\n"
  "\013PUBLISHTYPE\022\014\n\010REGISTER\020\000\022\016\n\nUNREGISTER"
  "\020\001\022\n\n\006CHANGE\020\002\"4\n\024SSLCLSGetAllNodesReq\022\034"
  "\n\tnode_type\030\001 \001(\0162\t.NODETYPE\"2\n\024SSLSLCGe"
  "tAllNodesRsp\022\032\n\005nodes\030\001 \003(\0132\013.SSLCLSNode"
  "\"9\n\031SSLCLSGetLeastLoadNodeReq\022\034\n\tnode_ty"
  "pe\030\001 \001(\0162\t.NODETYPE\"6\n\031SSLSLCGetLeastLoa"
  "dNodeRsp\022\031\n\004node\030\001 \001(\0132\013.SSLCLSNode\"\205\004\n\r"
  "SSLCLSPkgBody\022,\n\rnode_register\030\001 \001(\0132\023.S"
  "SLCLSNodeRegisterH\000\0220\n\017node_unregister\030\002"
  " \001(\0132\025.SSLCLSNodeUnregisterH\000\022-\n\016heart_b"
  "eat_req\030\003 \001(\0132\023.SSLCLSHeartBeatReqH\000\022-\n\016"
  "heart_beat_rsp\030\004 \001(\0132\023.SSLSLCHeartBeatRs"
  "pH\000\022%\n\tsubscribe\030\005 \001(\0132\020.SSLCLSSubscribe"
  "H\000\022!\n\007publish\030\006 \001(\0132\016.SSLSLCPublishH\000\0222\n"
  "\021get_all_nodes_req\030\007 \001(\0132\025.SSLCLSGetAllN"
  "odesReqH\000\0222\n\021get_all_nodes_rsp\030\010 \001(\0132\025.S"
  "SLSLCGetAllNodesRspH\000\022=\n\027get_least_load_"
  "node_req\030\t \001(\0132\032.SSLCLSGetLeastLoadNodeR"
  "eqH\000\022=\n\027get_least_load_node_rsp\030\n \001(\0132\032."
  "SSLSLCGetLeastLoadNodeRspH\000B\006\n\004bodyb\006pro"
  "to3"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_sslcls_2eproto_deps[1] = {
  &::descriptor_table_common_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_sslcls_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_sslcls_2eproto = {
  false, false, 1243, descriptor_table_protodef_sslcls_2eproto, "sslcls.proto", 
  &descriptor_table_sslcls_2eproto_once, descriptor_table_sslcls_2eproto_deps, 1, 12,
  schemas, file_default_instances, TableStruct_sslcls_2eproto::offsets,
  file_level_metadata_sslcls_2eproto, file_level_enum_descriptors_sslcls_2eproto, file_level_service_descriptors_sslcls_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_sslcls_2eproto_getter() {
  return &descriptor_table_sslcls_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_sslcls_2eproto(&descriptor_table_sslcls_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SSLSLCPublish_PUBLISHTYPE_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_sslcls_2eproto);
  return file_level_enum_descriptors_sslcls_2eproto[0];
}
bool SSLSLCPublish_PUBLISHTYPE_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SSLSLCPublish_PUBLISHTYPE SSLSLCPublish::REGISTER;
constexpr SSLSLCPublish_PUBLISHTYPE SSLSLCPublish::UNREGISTER;
constexpr SSLSLCPublish_PUBLISHTYPE SSLSLCPublish::CHANGE;
constexpr SSLSLCPublish_PUBLISHTYPE SSLSLCPublish::PUBLISHTYPE_MIN;
constexpr SSLSLCPublish_PUBLISHTYPE SSLSLCPublish::PUBLISHTYPE_MAX;
constexpr int SSLSLCPublish::PUBLISHTYPE_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class SSLCLSNode::_Internal {
 public:
};

SSLCLSNode::SSLCLSNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:SSLCLSNode)
}
SSLCLSNode::SSLCLSNode(const SSLCLSNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ip().empty()) {
    ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_ip(), 
      GetArenaForAllocation());
  }
  ::memcpy(&node_type_, &from.node_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&port_) -
    reinterpret_cast<char*>(&node_type_)) + sizeof(port_));
  // @@protoc_insertion_point(copy_constructor:SSLCLSNode)
}

inline void SSLCLSNode::SharedCtor() {
ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&node_type_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&port_) -
    reinterpret_cast<char*>(&node_type_)) + sizeof(port_));
}

SSLCLSNode::~SSLCLSNode() {
  // @@protoc_insertion_point(destructor:SSLCLSNode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SSLCLSNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ip_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void SSLCLSNode::ArenaDtor(void* object) {
  SSLCLSNode* _this = reinterpret_cast< SSLCLSNode* >(object);
  (void)_this;
}
void SSLCLSNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SSLCLSNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SSLCLSNode::Clear() {
// @@protoc_insertion_point(message_clear_start:SSLCLSNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ip_.ClearToEmpty();
  ::memset(&node_type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&port_) -
      reinterpret_cast<char*>(&node_type_)) + sizeof(port_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SSLCLSNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .NODETYPE node_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_node_type(static_cast<::NODETYPE>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 node_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string ip = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_ip();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "SSLCLSNode.ip"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 port = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SSLCLSNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SSLCLSNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .NODETYPE node_type = 1;
  if (this->_internal_node_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_node_type(), target);
  }

  // uint32 node_id = 2;
  if (this->_internal_node_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_node_id(), target);
  }

  // string ip = 3;
  if (!this->_internal_ip().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_ip().data(), static_cast<int>(this->_internal_ip().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SSLCLSNode.ip");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_ip(), target);
  }

  // uint32 port = 4;
  if (this->_internal_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_port(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SSLCLSNode)
  return target;
}

size_t SSLCLSNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SSLCLSNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string ip = 3;
  if (!this->_internal_ip().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ip());
  }

  // .NODETYPE node_type = 1;
  if (this->_internal_node_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_node_type());
  }

  // uint32 node_id = 2;
  if (this->_internal_node_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_node_id());
  }

  // uint32 port = 4;
  if (this->_internal_port() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_port());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SSLCLSNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SSLCLSNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SSLCLSNode::GetClassData() const { return &_class_data_; }

void SSLCLSNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SSLCLSNode *>(to)->MergeFrom(
      static_cast<const SSLCLSNode &>(from));
}


void SSLCLSNode::MergeFrom(const SSLCLSNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SSLCLSNode)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_ip().empty()) {
    _internal_set_ip(from._internal_ip());
  }
  if (from._internal_node_type() != 0) {
    _internal_set_node_type(from._internal_node_type());
  }
  if (from._internal_node_id() != 0) {
    _internal_set_node_id(from._internal_node_id());
  }
  if (from._internal_port() != 0) {
    _internal_set_port(from._internal_port());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SSLCLSNode::CopyFrom(const SSLCLSNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SSLCLSNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SSLCLSNode::IsInitialized() const {
  return true;
}

void SSLCLSNode::InternalSwap(SSLCLSNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &ip_, lhs_arena,
      &other->ip_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SSLCLSNode, port_)
      + sizeof(SSLCLSNode::port_)
      - PROTOBUF_FIELD_OFFSET(SSLCLSNode, node_type_)>(
          reinterpret_cast<char*>(&node_type_),
          reinterpret_cast<char*>(&other->node_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SSLCLSNode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_sslcls_2eproto_getter, &descriptor_table_sslcls_2eproto_once,
      file_level_metadata_sslcls_2eproto[0]);
}

// ===================================================================

class SSLCLSNodeRegister::_Internal {
 public:
  static const ::SSLCLSNode& node(const SSLCLSNodeRegister* msg);
};

const ::SSLCLSNode&
SSLCLSNodeRegister::_Internal::node(const SSLCLSNodeRegister* msg) {
  return *msg->node_;
}
SSLCLSNodeRegister::SSLCLSNodeRegister(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:SSLCLSNodeRegister)
}
SSLCLSNodeRegister::SSLCLSNodeRegister(const SSLCLSNodeRegister& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_node()) {
    node_ = new ::SSLCLSNode(*from.node_);
  } else {
    node_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:SSLCLSNodeRegister)
}

inline void SSLCLSNodeRegister::SharedCtor() {
node_ = nullptr;
}

SSLCLSNodeRegister::~SSLCLSNodeRegister() {
  // @@protoc_insertion_point(destructor:SSLCLSNodeRegister)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SSLCLSNodeRegister::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete node_;
}

void SSLCLSNodeRegister::ArenaDtor(void* object) {
  SSLCLSNodeRegister* _this = reinterpret_cast< SSLCLSNodeRegister* >(object);
  (void)_this;
}
void SSLCLSNodeRegister::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SSLCLSNodeRegister::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SSLCLSNodeRegister::Clear() {
// @@protoc_insertion_point(message_clear_start:SSLCLSNodeRegister)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && node_ != nullptr) {
    delete node_;
  }
  node_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SSLCLSNodeRegister::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .SSLCLSNode node = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SSLCLSNodeRegister::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SSLCLSNodeRegister)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .SSLCLSNode node = 1;
  if (this->_internal_has_node()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::node(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SSLCLSNodeRegister)
  return target;
}

size_t SSLCLSNodeRegister::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SSLCLSNodeRegister)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .SSLCLSNode node = 1;
  if (this->_internal_has_node()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *node_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SSLCLSNodeRegister::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SSLCLSNodeRegister::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SSLCLSNodeRegister::GetClassData() const { return &_class_data_; }

void SSLCLSNodeRegister::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SSLCLSNodeRegister *>(to)->MergeFrom(
      static_cast<const SSLCLSNodeRegister &>(from));
}


void SSLCLSNodeRegister::MergeFrom(const SSLCLSNodeRegister& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SSLCLSNodeRegister)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_node()) {
    _internal_mutable_node()->::SSLCLSNode::MergeFrom(from._internal_node());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SSLCLSNodeRegister::CopyFrom(const SSLCLSNodeRegister& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SSLCLSNodeRegister)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SSLCLSNodeRegister::IsInitialized() const {
  return true;
}

void SSLCLSNodeRegister::InternalSwap(SSLCLSNodeRegister* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(node_, other->node_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SSLCLSNodeRegister::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_sslcls_2eproto_getter, &descriptor_table_sslcls_2eproto_once,
      file_level_metadata_sslcls_2eproto[1]);
}

// ===================================================================

class SSLCLSNodeUnregister::_Internal {
 public:
};

SSLCLSNodeUnregister::SSLCLSNodeUnregister(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:SSLCLSNodeUnregister)
}
SSLCLSNodeUnregister::SSLCLSNodeUnregister(const SSLCLSNodeUnregister& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&node_type_, &from.node_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&node_id_) -
    reinterpret_cast<char*>(&node_type_)) + sizeof(node_id_));
  // @@protoc_insertion_point(copy_constructor:SSLCLSNodeUnregister)
}

inline void SSLCLSNodeUnregister::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&node_type_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&node_id_) -
    reinterpret_cast<char*>(&node_type_)) + sizeof(node_id_));
}

SSLCLSNodeUnregister::~SSLCLSNodeUnregister() {
  // @@protoc_insertion_point(destructor:SSLCLSNodeUnregister)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SSLCLSNodeUnregister::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SSLCLSNodeUnregister::ArenaDtor(void* object) {
  SSLCLSNodeUnregister* _this = reinterpret_cast< SSLCLSNodeUnregister* >(object);
  (void)_this;
}
void SSLCLSNodeUnregister::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SSLCLSNodeUnregister::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SSLCLSNodeUnregister::Clear() {
// @@protoc_insertion_point(message_clear_start:SSLCLSNodeUnregister)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&node_type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&node_id_) -
      reinterpret_cast<char*>(&node_type_)) + sizeof(node_id_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SSLCLSNodeUnregister::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .NODETYPE node_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_node_type(static_cast<::NODETYPE>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 node_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SSLCLSNodeUnregister::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SSLCLSNodeUnregister)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .NODETYPE node_type = 1;
  if (this->_internal_node_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_node_type(), target);
  }

  // uint32 node_id = 2;
  if (this->_internal_node_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_node_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SSLCLSNodeUnregister)
  return target;
}

size_t SSLCLSNodeUnregister::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SSLCLSNodeUnregister)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .NODETYPE node_type = 1;
  if (this->_internal_node_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_node_type());
  }

  // uint32 node_id = 2;
  if (this->_internal_node_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_node_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SSLCLSNodeUnregister::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SSLCLSNodeUnregister::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SSLCLSNodeUnregister::GetClassData() const { return &_class_data_; }

void SSLCLSNodeUnregister::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SSLCLSNodeUnregister *>(to)->MergeFrom(
      static_cast<const SSLCLSNodeUnregister &>(from));
}


void SSLCLSNodeUnregister::MergeFrom(const SSLCLSNodeUnregister& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SSLCLSNodeUnregister)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_node_type() != 0) {
    _internal_set_node_type(from._internal_node_type());
  }
  if (from._internal_node_id() != 0) {
    _internal_set_node_id(from._internal_node_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SSLCLSNodeUnregister::CopyFrom(const SSLCLSNodeUnregister& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SSLCLSNodeUnregister)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SSLCLSNodeUnregister::IsInitialized() const {
  return true;
}

void SSLCLSNodeUnregister::InternalSwap(SSLCLSNodeUnregister* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SSLCLSNodeUnregister, node_id_)
      + sizeof(SSLCLSNodeUnregister::node_id_)
      - PROTOBUF_FIELD_OFFSET(SSLCLSNodeUnregister, node_type_)>(
          reinterpret_cast<char*>(&node_type_),
          reinterpret_cast<char*>(&other->node_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SSLCLSNodeUnregister::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_sslcls_2eproto_getter, &descriptor_table_sslcls_2eproto_once,
      file_level_metadata_sslcls_2eproto[2]);
}

// ===================================================================

class SSLCLSHeartBeatReq::_Internal {
 public:
};

SSLCLSHeartBeatReq::SSLCLSHeartBeatReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:SSLCLSHeartBeatReq)
}
SSLCLSHeartBeatReq::SSLCLSHeartBeatReq(const SSLCLSHeartBeatReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  load_ = from.load_;
  // @@protoc_insertion_point(copy_constructor:SSLCLSHeartBeatReq)
}

inline void SSLCLSHeartBeatReq::SharedCtor() {
load_ = 0u;
}

SSLCLSHeartBeatReq::~SSLCLSHeartBeatReq() {
  // @@protoc_insertion_point(destructor:SSLCLSHeartBeatReq)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SSLCLSHeartBeatReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SSLCLSHeartBeatReq::ArenaDtor(void* object) {
  SSLCLSHeartBeatReq* _this = reinterpret_cast< SSLCLSHeartBeatReq* >(object);
  (void)_this;
}
void SSLCLSHeartBeatReq::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SSLCLSHeartBeatReq::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SSLCLSHeartBeatReq::Clear() {
// @@protoc_insertion_point(message_clear_start:SSLCLSHeartBeatReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  load_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SSLCLSHeartBeatReq::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 load = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          load_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SSLCLSHeartBeatReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SSLCLSHeartBeatReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 load = 1;
  if (this->_internal_load() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_load(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SSLCLSHeartBeatReq)
  return target;
}

size_t SSLCLSHeartBeatReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SSLCLSHeartBeatReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 load = 1;
  if (this->_internal_load() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_load());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SSLCLSHeartBeatReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SSLCLSHeartBeatReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SSLCLSHeartBeatReq::GetClassData() const { return &_class_data_; }

void SSLCLSHeartBeatReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SSLCLSHeartBeatReq *>(to)->MergeFrom(
      static_cast<const SSLCLSHeartBeatReq &>(from));
}


void SSLCLSHeartBeatReq::MergeFrom(const SSLCLSHeartBeatReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SSLCLSHeartBeatReq)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_load() != 0) {
    _internal_set_load(from._internal_load());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SSLCLSHeartBeatReq::CopyFrom(const SSLCLSHeartBeatReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SSLCLSHeartBeatReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SSLCLSHeartBeatReq::IsInitialized() const {
  return true;
}

void SSLCLSHeartBeatReq::InternalSwap(SSLCLSHeartBeatReq* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(load_, other->load_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SSLCLSHeartBeatReq::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_sslcls_2eproto_getter, &descriptor_table_sslcls_2eproto_once,
      file_level_metadata_sslcls_2eproto[3]);
}

// ===================================================================

class SSLSLCHeartBeatRsp::_Internal {
 public:
};

SSLSLCHeartBeatRsp::SSLSLCHeartBeatRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:SSLSLCHeartBeatRsp)
}
SSLSLCHeartBeatRsp::SSLSLCHeartBeatRsp(const SSLSLCHeartBeatRsp& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:SSLSLCHeartBeatRsp)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SSLSLCHeartBeatRsp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SSLSLCHeartBeatRsp::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata SSLSLCHeartBeatRsp::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_sslcls_2eproto_getter, &descriptor_table_sslcls_2eproto_once,
      file_level_metadata_sslcls_2eproto[4]);
}

// ===================================================================

class SSLCLSSubscribe::_Internal {
 public:
};

SSLCLSSubscribe::SSLCLSSubscribe(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:SSLCLSSubscribe)
}
SSLCLSSubscribe::SSLCLSSubscribe(const SSLCLSSubscribe& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  node_type_ = from.node_type_;
  // @@protoc_insertion_point(copy_constructor:SSLCLSSubscribe)
}

inline void SSLCLSSubscribe::SharedCtor() {
node_type_ = 0;
}

SSLCLSSubscribe::~SSLCLSSubscribe() {
  // @@protoc_insertion_point(destructor:SSLCLSSubscribe)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SSLCLSSubscribe::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SSLCLSSubscribe::ArenaDtor(void* object) {
  SSLCLSSubscribe* _this = reinterpret_cast< SSLCLSSubscribe* >(object);
  (void)_this;
}
void SSLCLSSubscribe::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SSLCLSSubscribe::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SSLCLSSubscribe::Clear() {
// @@protoc_insertion_point(message_clear_start:SSLCLSSubscribe)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  node_type_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SSLCLSSubscribe::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .NODETYPE node_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_node_type(static_cast<::NODETYPE>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SSLCLSSubscribe::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SSLCLSSubscribe)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .NODETYPE node_type = 1;
  if (this->_internal_node_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_node_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SSLCLSSubscribe)
  return target;
}

size_t SSLCLSSubscribe::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SSLCLSSubscribe)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .NODETYPE node_type = 1;
  if (this->_internal_node_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_node_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SSLCLSSubscribe::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SSLCLSSubscribe::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SSLCLSSubscribe::GetClassData() const { return &_class_data_; }

void SSLCLSSubscribe::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SSLCLSSubscribe *>(to)->MergeFrom(
      static_cast<const SSLCLSSubscribe &>(from));
}


void SSLCLSSubscribe::MergeFrom(const SSLCLSSubscribe& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SSLCLSSubscribe)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_node_type() != 0) {
    _internal_set_node_type(from._internal_node_type());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SSLCLSSubscribe::CopyFrom(const SSLCLSSubscribe& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SSLCLSSubscribe)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SSLCLSSubscribe::IsInitialized() const {
  return true;
}

void SSLCLSSubscribe::InternalSwap(SSLCLSSubscribe* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(node_type_, other->node_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SSLCLSSubscribe::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_sslcls_2eproto_getter, &descriptor_table_sslcls_2eproto_once,
      file_level_metadata_sslcls_2eproto[5]);
}

// ===================================================================

class SSLSLCPublish::_Internal {
 public:
  static const ::SSLCLSNode& node(const SSLSLCPublish* msg);
};

const ::SSLCLSNode&
SSLSLCPublish::_Internal::node(const SSLSLCPublish* msg) {
  return *msg->node_;
}
SSLSLCPublish::SSLSLCPublish(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:SSLSLCPublish)
}
SSLSLCPublish::SSLSLCPublish(const SSLSLCPublish& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_node()) {
    node_ = new ::SSLCLSNode(*from.node_);
  } else {
    node_ = nullptr;
  }
  publish_type_ = from.publish_type_;
  // @@protoc_insertion_point(copy_constructor:SSLSLCPublish)
}

inline void SSLSLCPublish::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&node_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&publish_type_) -
    reinterpret_cast<char*>(&node_)) + sizeof(publish_type_));
}

SSLSLCPublish::~SSLSLCPublish() {
  // @@protoc_insertion_point(destructor:SSLSLCPublish)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SSLSLCPublish::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete node_;
}

void SSLSLCPublish::ArenaDtor(void* object) {
  SSLSLCPublish* _this = reinterpret_cast< SSLSLCPublish* >(object);
  (void)_this;
}
void SSLSLCPublish::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SSLSLCPublish::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SSLSLCPublish::Clear() {
// @@protoc_insertion_point(message_clear_start:SSLSLCPublish)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && node_ != nullptr) {
    delete node_;
  }
  node_ = nullptr;
  publish_type_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SSLSLCPublish::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .SSLSLCPublish.PUBLISHTYPE publish_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_publish_type(static_cast<::SSLSLCPublish_PUBLISHTYPE>(val));
        } else
          goto handle_unusual;
        continue;
      // .SSLCLSNode node = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SSLSLCPublish::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SSLSLCPublish)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .SSLSLCPublish.PUBLISHTYPE publish_type = 1;
  if (this->_internal_publish_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_publish_type(), target);
  }

  // .SSLCLSNode node = 2;
  if (this->_internal_has_node()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::node(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SSLSLCPublish)
  return target;
}

size_t SSLSLCPublish::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SSLSLCPublish)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .SSLCLSNode node = 2;
  if (this->_internal_has_node()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *node_);
  }

  // .SSLSLCPublish.PUBLISHTYPE publish_type = 1;
  if (this->_internal_publish_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_publish_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SSLSLCPublish::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SSLSLCPublish::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SSLSLCPublish::GetClassData() const { return &_class_data_; }

void SSLSLCPublish::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SSLSLCPublish *>(to)->MergeFrom(
      static_cast<const SSLSLCPublish &>(from));
}


void SSLSLCPublish::MergeFrom(const SSLSLCPublish& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SSLSLCPublish)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_node()) {
    _internal_mutable_node()->::SSLCLSNode::MergeFrom(from._internal_node());
  }
  if (from._internal_publish_type() != 0) {
    _internal_set_publish_type(from._internal_publish_type());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SSLSLCPublish::CopyFrom(const SSLSLCPublish& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SSLSLCPublish)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SSLSLCPublish::IsInitialized() const {
  return true;
}

void SSLSLCPublish::InternalSwap(SSLSLCPublish* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SSLSLCPublish, publish_type_)
      + sizeof(SSLSLCPublish::publish_type_)
      - PROTOBUF_FIELD_OFFSET(SSLSLCPublish, node_)>(
          reinterpret_cast<char*>(&node_),
          reinterpret_cast<char*>(&other->node_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SSLSLCPublish::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_sslcls_2eproto_getter, &descriptor_table_sslcls_2eproto_once,
      file_level_metadata_sslcls_2eproto[6]);
}

// ===================================================================

class SSLCLSGetAllNodesReq::_Internal {
 public:
};

SSLCLSGetAllNodesReq::SSLCLSGetAllNodesReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:SSLCLSGetAllNodesReq)
}
SSLCLSGetAllNodesReq::SSLCLSGetAllNodesReq(const SSLCLSGetAllNodesReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  node_type_ = from.node_type_;
  // @@protoc_insertion_point(copy_constructor:SSLCLSGetAllNodesReq)
}

inline void SSLCLSGetAllNodesReq::SharedCtor() {
node_type_ = 0;
}

SSLCLSGetAllNodesReq::~SSLCLSGetAllNodesReq() {
  // @@protoc_insertion_point(destructor:SSLCLSGetAllNodesReq)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SSLCLSGetAllNodesReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SSLCLSGetAllNodesReq::ArenaDtor(void* object) {
  SSLCLSGetAllNodesReq* _this = reinterpret_cast< SSLCLSGetAllNodesReq* >(object);
  (void)_this;
}
void SSLCLSGetAllNodesReq::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SSLCLSGetAllNodesReq::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SSLCLSGetAllNodesReq::Clear() {
// @@protoc_insertion_point(message_clear_start:SSLCLSGetAllNodesReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  node_type_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SSLCLSGetAllNodesReq::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .NODETYPE node_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_node_type(static_cast<::NODETYPE>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SSLCLSGetAllNodesReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SSLCLSGetAllNodesReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .NODETYPE node_type = 1;
  if (this->_internal_node_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_node_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SSLCLSGetAllNodesReq)
  return target;
}

size_t SSLCLSGetAllNodesReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SSLCLSGetAllNodesReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .NODETYPE node_type = 1;
  if (this->_internal_node_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_node_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SSLCLSGetAllNodesReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SSLCLSGetAllNodesReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SSLCLSGetAllNodesReq::GetClassData() const { return &_class_data_; }

void SSLCLSGetAllNodesReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SSLCLSGetAllNodesReq *>(to)->MergeFrom(
      static_cast<const SSLCLSGetAllNodesReq &>(from));
}


void SSLCLSGetAllNodesReq::MergeFrom(const SSLCLSGetAllNodesReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SSLCLSGetAllNodesReq)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_node_type() != 0) {
    _internal_set_node_type(from._internal_node_type());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SSLCLSGetAllNodesReq::CopyFrom(const SSLCLSGetAllNodesReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SSLCLSGetAllNodesReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SSLCLSGetAllNodesReq::IsInitialized() const {
  return true;
}

void SSLCLSGetAllNodesReq::InternalSwap(SSLCLSGetAllNodesReq* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(node_type_, other->node_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SSLCLSGetAllNodesReq::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_sslcls_2eproto_getter, &descriptor_table_sslcls_2eproto_once,
      file_level_metadata_sslcls_2eproto[7]);
}

// ===================================================================

class SSLSLCGetAllNodesRsp::_Internal {
 public:
};

SSLSLCGetAllNodesRsp::SSLSLCGetAllNodesRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  nodes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:SSLSLCGetAllNodesRsp)
}
SSLSLCGetAllNodesRsp::SSLSLCGetAllNodesRsp(const SSLSLCGetAllNodesRsp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      nodes_(from.nodes_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:SSLSLCGetAllNodesRsp)
}

inline void SSLSLCGetAllNodesRsp::SharedCtor() {
}

SSLSLCGetAllNodesRsp::~SSLSLCGetAllNodesRsp() {
  // @@protoc_insertion_point(destructor:SSLSLCGetAllNodesRsp)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SSLSLCGetAllNodesRsp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SSLSLCGetAllNodesRsp::ArenaDtor(void* object) {
  SSLSLCGetAllNodesRsp* _this = reinterpret_cast< SSLSLCGetAllNodesRsp* >(object);
  (void)_this;
}
void SSLSLCGetAllNodesRsp::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SSLSLCGetAllNodesRsp::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SSLSLCGetAllNodesRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:SSLSLCGetAllNodesRsp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nodes_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SSLSLCGetAllNodesRsp::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .SSLCLSNode nodes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nodes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SSLSLCGetAllNodesRsp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SSLSLCGetAllNodesRsp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .SSLCLSNode nodes = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_nodes_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_nodes(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SSLSLCGetAllNodesRsp)
  return target;
}

size_t SSLSLCGetAllNodesRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SSLSLCGetAllNodesRsp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .SSLCLSNode nodes = 1;
  total_size += 1UL * this->_internal_nodes_size();
  for (const auto& msg : this->nodes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SSLSLCGetAllNodesRsp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SSLSLCGetAllNodesRsp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SSLSLCGetAllNodesRsp::GetClassData() const { return &_class_data_; }

void SSLSLCGetAllNodesRsp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SSLSLCGetAllNodesRsp *>(to)->MergeFrom(
      static_cast<const SSLSLCGetAllNodesRsp &>(from));
}


void SSLSLCGetAllNodesRsp::MergeFrom(const SSLSLCGetAllNodesRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SSLSLCGetAllNodesRsp)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  nodes_.MergeFrom(from.nodes_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SSLSLCGetAllNodesRsp::CopyFrom(const SSLSLCGetAllNodesRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SSLSLCGetAllNodesRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SSLSLCGetAllNodesRsp::IsInitialized() const {
  return true;
}

void SSLSLCGetAllNodesRsp::InternalSwap(SSLSLCGetAllNodesRsp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  nodes_.InternalSwap(&other->nodes_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SSLSLCGetAllNodesRsp::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_sslcls_2eproto_getter, &descriptor_table_sslcls_2eproto_once,
      file_level_metadata_sslcls_2eproto[8]);
}

// ===================================================================

class SSLCLSGetLeastLoadNodeReq::_Internal {
 public:
};

SSLCLSGetLeastLoadNodeReq::SSLCLSGetLeastLoadNodeReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:SSLCLSGetLeastLoadNodeReq)
}
SSLCLSGetLeastLoadNodeReq::SSLCLSGetLeastLoadNodeReq(const SSLCLSGetLeastLoadNodeReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  node_type_ = from.node_type_;
  // @@protoc_insertion_point(copy_constructor:SSLCLSGetLeastLoadNodeReq)
}

inline void SSLCLSGetLeastLoadNodeReq::SharedCtor() {
node_type_ = 0;
}

SSLCLSGetLeastLoadNodeReq::~SSLCLSGetLeastLoadNodeReq() {
  // @@protoc_insertion_point(destructor:SSLCLSGetLeastLoadNodeReq)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SSLCLSGetLeastLoadNodeReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SSLCLSGetLeastLoadNodeReq::ArenaDtor(void* object) {
  SSLCLSGetLeastLoadNodeReq* _this = reinterpret_cast< SSLCLSGetLeastLoadNodeReq* >(object);
  (void)_this;
}
void SSLCLSGetLeastLoadNodeReq::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SSLCLSGetLeastLoadNodeReq::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SSLCLSGetLeastLoadNodeReq::Clear() {
// @@protoc_insertion_point(message_clear_start:SSLCLSGetLeastLoadNodeReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  node_type_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SSLCLSGetLeastLoadNodeReq::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .NODETYPE node_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_node_type(static_cast<::NODETYPE>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SSLCLSGetLeastLoadNodeReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SSLCLSGetLeastLoadNodeReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .NODETYPE node_type = 1;
  if (this->_internal_node_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_node_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SSLCLSGetLeastLoadNodeReq)
  return target;
}

size_t SSLCLSGetLeastLoadNodeReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SSLCLSGetLeastLoadNodeReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .NODETYPE node_type = 1;
  if (this->_internal_node_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_node_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SSLCLSGetLeastLoadNodeReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SSLCLSGetLeastLoadNodeReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SSLCLSGetLeastLoadNodeReq::GetClassData() const { return &_class_data_; }

void SSLCLSGetLeastLoadNodeReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SSLCLSGetLeastLoadNodeReq *>(to)->MergeFrom(
      static_cast<const SSLCLSGetLeastLoadNodeReq &>(from));
}


void SSLCLSGetLeastLoadNodeReq::MergeFrom(const SSLCLSGetLeastLoadNodeReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SSLCLSGetLeastLoadNodeReq)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_node_type() != 0) {
    _internal_set_node_type(from._internal_node_type());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SSLCLSGetLeastLoadNodeReq::CopyFrom(const SSLCLSGetLeastLoadNodeReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SSLCLSGetLeastLoadNodeReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SSLCLSGetLeastLoadNodeReq::IsInitialized() const {
  return true;
}

void SSLCLSGetLeastLoadNodeReq::InternalSwap(SSLCLSGetLeastLoadNodeReq* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(node_type_, other->node_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SSLCLSGetLeastLoadNodeReq::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_sslcls_2eproto_getter, &descriptor_table_sslcls_2eproto_once,
      file_level_metadata_sslcls_2eproto[9]);
}

// ===================================================================

class SSLSLCGetLeastLoadNodeRsp::_Internal {
 public:
  static const ::SSLCLSNode& node(const SSLSLCGetLeastLoadNodeRsp* msg);
};

const ::SSLCLSNode&
SSLSLCGetLeastLoadNodeRsp::_Internal::node(const SSLSLCGetLeastLoadNodeRsp* msg) {
  return *msg->node_;
}
SSLSLCGetLeastLoadNodeRsp::SSLSLCGetLeastLoadNodeRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:SSLSLCGetLeastLoadNodeRsp)
}
SSLSLCGetLeastLoadNodeRsp::SSLSLCGetLeastLoadNodeRsp(const SSLSLCGetLeastLoadNodeRsp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_node()) {
    node_ = new ::SSLCLSNode(*from.node_);
  } else {
    node_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:SSLSLCGetLeastLoadNodeRsp)
}

inline void SSLSLCGetLeastLoadNodeRsp::SharedCtor() {
node_ = nullptr;
}

SSLSLCGetLeastLoadNodeRsp::~SSLSLCGetLeastLoadNodeRsp() {
  // @@protoc_insertion_point(destructor:SSLSLCGetLeastLoadNodeRsp)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SSLSLCGetLeastLoadNodeRsp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete node_;
}

void SSLSLCGetLeastLoadNodeRsp::ArenaDtor(void* object) {
  SSLSLCGetLeastLoadNodeRsp* _this = reinterpret_cast< SSLSLCGetLeastLoadNodeRsp* >(object);
  (void)_this;
}
void SSLSLCGetLeastLoadNodeRsp::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SSLSLCGetLeastLoadNodeRsp::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SSLSLCGetLeastLoadNodeRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:SSLSLCGetLeastLoadNodeRsp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && node_ != nullptr) {
    delete node_;
  }
  node_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SSLSLCGetLeastLoadNodeRsp::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .SSLCLSNode node = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SSLSLCGetLeastLoadNodeRsp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SSLSLCGetLeastLoadNodeRsp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .SSLCLSNode node = 1;
  if (this->_internal_has_node()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::node(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SSLSLCGetLeastLoadNodeRsp)
  return target;
}

size_t SSLSLCGetLeastLoadNodeRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SSLSLCGetLeastLoadNodeRsp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .SSLCLSNode node = 1;
  if (this->_internal_has_node()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *node_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SSLSLCGetLeastLoadNodeRsp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SSLSLCGetLeastLoadNodeRsp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SSLSLCGetLeastLoadNodeRsp::GetClassData() const { return &_class_data_; }

void SSLSLCGetLeastLoadNodeRsp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SSLSLCGetLeastLoadNodeRsp *>(to)->MergeFrom(
      static_cast<const SSLSLCGetLeastLoadNodeRsp &>(from));
}


void SSLSLCGetLeastLoadNodeRsp::MergeFrom(const SSLSLCGetLeastLoadNodeRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SSLSLCGetLeastLoadNodeRsp)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_node()) {
    _internal_mutable_node()->::SSLCLSNode::MergeFrom(from._internal_node());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SSLSLCGetLeastLoadNodeRsp::CopyFrom(const SSLSLCGetLeastLoadNodeRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SSLSLCGetLeastLoadNodeRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SSLSLCGetLeastLoadNodeRsp::IsInitialized() const {
  return true;
}

void SSLSLCGetLeastLoadNodeRsp::InternalSwap(SSLSLCGetLeastLoadNodeRsp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(node_, other->node_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SSLSLCGetLeastLoadNodeRsp::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_sslcls_2eproto_getter, &descriptor_table_sslcls_2eproto_once,
      file_level_metadata_sslcls_2eproto[10]);
}

// ===================================================================

class SSLCLSPkgBody::_Internal {
 public:
  static const ::SSLCLSNodeRegister& node_register(const SSLCLSPkgBody* msg);
  static const ::SSLCLSNodeUnregister& node_unregister(const SSLCLSPkgBody* msg);
  static const ::SSLCLSHeartBeatReq& heart_beat_req(const SSLCLSPkgBody* msg);
  static const ::SSLSLCHeartBeatRsp& heart_beat_rsp(const SSLCLSPkgBody* msg);
  static const ::SSLCLSSubscribe& subscribe(const SSLCLSPkgBody* msg);
  static const ::SSLSLCPublish& publish(const SSLCLSPkgBody* msg);
  static const ::SSLCLSGetAllNodesReq& get_all_nodes_req(const SSLCLSPkgBody* msg);
  static const ::SSLSLCGetAllNodesRsp& get_all_nodes_rsp(const SSLCLSPkgBody* msg);
  static const ::SSLCLSGetLeastLoadNodeReq& get_least_load_node_req(const SSLCLSPkgBody* msg);
  static const ::SSLSLCGetLeastLoadNodeRsp& get_least_load_node_rsp(const SSLCLSPkgBody* msg);
};

const ::SSLCLSNodeRegister&
SSLCLSPkgBody::_Internal::node_register(const SSLCLSPkgBody* msg) {
  return *msg->body_.node_register_;
}
const ::SSLCLSNodeUnregister&
SSLCLSPkgBody::_Internal::node_unregister(const SSLCLSPkgBody* msg) {
  return *msg->body_.node_unregister_;
}
const ::SSLCLSHeartBeatReq&
SSLCLSPkgBody::_Internal::heart_beat_req(const SSLCLSPkgBody* msg) {
  return *msg->body_.heart_beat_req_;
}
const ::SSLSLCHeartBeatRsp&
SSLCLSPkgBody::_Internal::heart_beat_rsp(const SSLCLSPkgBody* msg) {
  return *msg->body_.heart_beat_rsp_;
}
const ::SSLCLSSubscribe&
SSLCLSPkgBody::_Internal::subscribe(const SSLCLSPkgBody* msg) {
  return *msg->body_.subscribe_;
}
const ::SSLSLCPublish&
SSLCLSPkgBody::_Internal::publish(const SSLCLSPkgBody* msg) {
  return *msg->body_.publish_;
}
const ::SSLCLSGetAllNodesReq&
SSLCLSPkgBody::_Internal::get_all_nodes_req(const SSLCLSPkgBody* msg) {
  return *msg->body_.get_all_nodes_req_;
}
const ::SSLSLCGetAllNodesRsp&
SSLCLSPkgBody::_Internal::get_all_nodes_rsp(const SSLCLSPkgBody* msg) {
  return *msg->body_.get_all_nodes_rsp_;
}
const ::SSLCLSGetLeastLoadNodeReq&
SSLCLSPkgBody::_Internal::get_least_load_node_req(const SSLCLSPkgBody* msg) {
  return *msg->body_.get_least_load_node_req_;
}
const ::SSLSLCGetLeastLoadNodeRsp&
SSLCLSPkgBody::_Internal::get_least_load_node_rsp(const SSLCLSPkgBody* msg) {
  return *msg->body_.get_least_load_node_rsp_;
}
void SSLCLSPkgBody::set_allocated_node_register(::SSLCLSNodeRegister* node_register) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_body();
  if (node_register) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::SSLCLSNodeRegister>::GetOwningArena(node_register);
    if (message_arena != submessage_arena) {
      node_register = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, node_register, submessage_arena);
    }
    set_has_node_register();
    body_.node_register_ = node_register;
  }
  // @@protoc_insertion_point(field_set_allocated:SSLCLSPkgBody.node_register)
}
void SSLCLSPkgBody::set_allocated_node_unregister(::SSLCLSNodeUnregister* node_unregister) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_body();
  if (node_unregister) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::SSLCLSNodeUnregister>::GetOwningArena(node_unregister);
    if (message_arena != submessage_arena) {
      node_unregister = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, node_unregister, submessage_arena);
    }
    set_has_node_unregister();
    body_.node_unregister_ = node_unregister;
  }
  // @@protoc_insertion_point(field_set_allocated:SSLCLSPkgBody.node_unregister)
}
void SSLCLSPkgBody::set_allocated_heart_beat_req(::SSLCLSHeartBeatReq* heart_beat_req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_body();
  if (heart_beat_req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::SSLCLSHeartBeatReq>::GetOwningArena(heart_beat_req);
    if (message_arena != submessage_arena) {
      heart_beat_req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, heart_beat_req, submessage_arena);
    }
    set_has_heart_beat_req();
    body_.heart_beat_req_ = heart_beat_req;
  }
  // @@protoc_insertion_point(field_set_allocated:SSLCLSPkgBody.heart_beat_req)
}
void SSLCLSPkgBody::set_allocated_heart_beat_rsp(::SSLSLCHeartBeatRsp* heart_beat_rsp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_body();
  if (heart_beat_rsp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::SSLSLCHeartBeatRsp>::GetOwningArena(heart_beat_rsp);
    if (message_arena != submessage_arena) {
      heart_beat_rsp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, heart_beat_rsp, submessage_arena);
    }
    set_has_heart_beat_rsp();
    body_.heart_beat_rsp_ = heart_beat_rsp;
  }
  // @@protoc_insertion_point(field_set_allocated:SSLCLSPkgBody.heart_beat_rsp)
}
void SSLCLSPkgBody::set_allocated_subscribe(::SSLCLSSubscribe* subscribe) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_body();
  if (subscribe) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::SSLCLSSubscribe>::GetOwningArena(subscribe);
    if (message_arena != submessage_arena) {
      subscribe = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subscribe, submessage_arena);
    }
    set_has_subscribe();
    body_.subscribe_ = subscribe;
  }
  // @@protoc_insertion_point(field_set_allocated:SSLCLSPkgBody.subscribe)
}
void SSLCLSPkgBody::set_allocated_publish(::SSLSLCPublish* publish) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_body();
  if (publish) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::SSLSLCPublish>::GetOwningArena(publish);
    if (message_arena != submessage_arena) {
      publish = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, publish, submessage_arena);
    }
    set_has_publish();
    body_.publish_ = publish;
  }
  // @@protoc_insertion_point(field_set_allocated:SSLCLSPkgBody.publish)
}
void SSLCLSPkgBody::set_allocated_get_all_nodes_req(::SSLCLSGetAllNodesReq* get_all_nodes_req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_body();
  if (get_all_nodes_req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::SSLCLSGetAllNodesReq>::GetOwningArena(get_all_nodes_req);
    if (message_arena != submessage_arena) {
      get_all_nodes_req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, get_all_nodes_req, submessage_arena);
    }
    set_has_get_all_nodes_req();
    body_.get_all_nodes_req_ = get_all_nodes_req;
  }
  // @@protoc_insertion_point(field_set_allocated:SSLCLSPkgBody.get_all_nodes_req)
}
void SSLCLSPkgBody::set_allocated_get_all_nodes_rsp(::SSLSLCGetAllNodesRsp* get_all_nodes_rsp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_body();
  if (get_all_nodes_rsp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::SSLSLCGetAllNodesRsp>::GetOwningArena(get_all_nodes_rsp);
    if (message_arena != submessage_arena) {
      get_all_nodes_rsp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, get_all_nodes_rsp, submessage_arena);
    }
    set_has_get_all_nodes_rsp();
    body_.get_all_nodes_rsp_ = get_all_nodes_rsp;
  }
  // @@protoc_insertion_point(field_set_allocated:SSLCLSPkgBody.get_all_nodes_rsp)
}
void SSLCLSPkgBody::set_allocated_get_least_load_node_req(::SSLCLSGetLeastLoadNodeReq* get_least_load_node_req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_body();
  if (get_least_load_node_req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::SSLCLSGetLeastLoadNodeReq>::GetOwningArena(get_least_load_node_req);
    if (message_arena != submessage_arena) {
      get_least_load_node_req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, get_least_load_node_req, submessage_arena);
    }
    set_has_get_least_load_node_req();
    body_.get_least_load_node_req_ = get_least_load_node_req;
  }
  // @@protoc_insertion_point(field_set_allocated:SSLCLSPkgBody.get_least_load_node_req)
}
void SSLCLSPkgBody::set_allocated_get_least_load_node_rsp(::SSLSLCGetLeastLoadNodeRsp* get_least_load_node_rsp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_body();
  if (get_least_load_node_rsp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::SSLSLCGetLeastLoadNodeRsp>::GetOwningArena(get_least_load_node_rsp);
    if (message_arena != submessage_arena) {
      get_least_load_node_rsp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, get_least_load_node_rsp, submessage_arena);
    }
    set_has_get_least_load_node_rsp();
    body_.get_least_load_node_rsp_ = get_least_load_node_rsp;
  }
  // @@protoc_insertion_point(field_set_allocated:SSLCLSPkgBody.get_least_load_node_rsp)
}
SSLCLSPkgBody::SSLCLSPkgBody(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:SSLCLSPkgBody)
}
SSLCLSPkgBody::SSLCLSPkgBody(const SSLCLSPkgBody& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_body();
  switch (from.body_case()) {
    case kNodeRegister: {
      _internal_mutable_node_register()->::SSLCLSNodeRegister::MergeFrom(from._internal_node_register());
      break;
    }
    case kNodeUnregister: {
      _internal_mutable_node_unregister()->::SSLCLSNodeUnregister::MergeFrom(from._internal_node_unregister());
      break;
    }
    case kHeartBeatReq: {
      _internal_mutable_heart_beat_req()->::SSLCLSHeartBeatReq::MergeFrom(from._internal_heart_beat_req());
      break;
    }
    case kHeartBeatRsp: {
      _internal_mutable_heart_beat_rsp()->::SSLSLCHeartBeatRsp::MergeFrom(from._internal_heart_beat_rsp());
      break;
    }
    case kSubscribe: {
      _internal_mutable_subscribe()->::SSLCLSSubscribe::MergeFrom(from._internal_subscribe());
      break;
    }
    case kPublish: {
      _internal_mutable_publish()->::SSLSLCPublish::MergeFrom(from._internal_publish());
      break;
    }
    case kGetAllNodesReq: {
      _internal_mutable_get_all_nodes_req()->::SSLCLSGetAllNodesReq::MergeFrom(from._internal_get_all_nodes_req());
      break;
    }
    case kGetAllNodesRsp: {
      _internal_mutable_get_all_nodes_rsp()->::SSLSLCGetAllNodesRsp::MergeFrom(from._internal_get_all_nodes_rsp());
      break;
    }
    case kGetLeastLoadNodeReq: {
      _internal_mutable_get_least_load_node_req()->::SSLCLSGetLeastLoadNodeReq::MergeFrom(from._internal_get_least_load_node_req());
      break;
    }
    case kGetLeastLoadNodeRsp: {
      _internal_mutable_get_least_load_node_rsp()->::SSLSLCGetLeastLoadNodeRsp::MergeFrom(from._internal_get_least_load_node_rsp());
      break;
    }
    case BODY_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:SSLCLSPkgBody)
}

inline void SSLCLSPkgBody::SharedCtor() {
clear_has_body();
}

SSLCLSPkgBody::~SSLCLSPkgBody() {
  // @@protoc_insertion_point(destructor:SSLCLSPkgBody)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SSLCLSPkgBody::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_body()) {
    clear_body();
  }
}

void SSLCLSPkgBody::ArenaDtor(void* object) {
  SSLCLSPkgBody* _this = reinterpret_cast< SSLCLSPkgBody* >(object);
  (void)_this;
}
void SSLCLSPkgBody::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SSLCLSPkgBody::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SSLCLSPkgBody::clear_body() {
// @@protoc_insertion_point(one_of_clear_start:SSLCLSPkgBody)
  switch (body_case()) {
    case kNodeRegister: {
      if (GetArenaForAllocation() == nullptr) {
        delete body_.node_register_;
      }
      break;
    }
    case kNodeUnregister: {
      if (GetArenaForAllocation() == nullptr) {
        delete body_.node_unregister_;
      }
      break;
    }
    case kHeartBeatReq: {
      if (GetArenaForAllocation() == nullptr) {
        delete body_.heart_beat_req_;
      }
      break;
    }
    case kHeartBeatRsp: {
      if (GetArenaForAllocation() == nullptr) {
        delete body_.heart_beat_rsp_;
      }
      break;
    }
    case kSubscribe: {
      if (GetArenaForAllocation() == nullptr) {
        delete body_.subscribe_;
      }
      break;
    }
    case kPublish: {
      if (GetArenaForAllocation() == nullptr) {
        delete body_.publish_;
      }
      break;
    }
    case kGetAllNodesReq: {
      if (GetArenaForAllocation() == nullptr) {
        delete body_.get_all_nodes_req_;
      }
      break;
    }
    case kGetAllNodesRsp: {
      if (GetArenaForAllocation() == nullptr) {
        delete body_.get_all_nodes_rsp_;
      }
      break;
    }
    case kGetLeastLoadNodeReq: {
      if (GetArenaForAllocation() == nullptr) {
        delete body_.get_least_load_node_req_;
      }
      break;
    }
    case kGetLeastLoadNodeRsp: {
      if (GetArenaForAllocation() == nullptr) {
        delete body_.get_least_load_node_rsp_;
      }
      break;
    }
    case BODY_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = BODY_NOT_SET;
}


void SSLCLSPkgBody::Clear() {
// @@protoc_insertion_point(message_clear_start:SSLCLSPkgBody)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_body();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SSLCLSPkgBody::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .SSLCLSNodeRegister node_register = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_node_register(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .SSLCLSNodeUnregister node_unregister = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_node_unregister(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .SSLCLSHeartBeatReq heart_beat_req = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_heart_beat_req(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .SSLSLCHeartBeatRsp heart_beat_rsp = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_heart_beat_rsp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .SSLCLSSubscribe subscribe = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_subscribe(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .SSLSLCPublish publish = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_publish(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .SSLCLSGetAllNodesReq get_all_nodes_req = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_get_all_nodes_req(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .SSLSLCGetAllNodesRsp get_all_nodes_rsp = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_get_all_nodes_rsp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .SSLCLSGetLeastLoadNodeReq get_least_load_node_req = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_get_least_load_node_req(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .SSLSLCGetLeastLoadNodeRsp get_least_load_node_rsp = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_get_least_load_node_rsp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SSLCLSPkgBody::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SSLCLSPkgBody)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .SSLCLSNodeRegister node_register = 1;
  if (_internal_has_node_register()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::node_register(this), target, stream);
  }

  // .SSLCLSNodeUnregister node_unregister = 2;
  if (_internal_has_node_unregister()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::node_unregister(this), target, stream);
  }

  // .SSLCLSHeartBeatReq heart_beat_req = 3;
  if (_internal_has_heart_beat_req()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::heart_beat_req(this), target, stream);
  }

  // .SSLSLCHeartBeatRsp heart_beat_rsp = 4;
  if (_internal_has_heart_beat_rsp()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::heart_beat_rsp(this), target, stream);
  }

  // .SSLCLSSubscribe subscribe = 5;
  if (_internal_has_subscribe()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::subscribe(this), target, stream);
  }

  // .SSLSLCPublish publish = 6;
  if (_internal_has_publish()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::publish(this), target, stream);
  }

  // .SSLCLSGetAllNodesReq get_all_nodes_req = 7;
  if (_internal_has_get_all_nodes_req()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::get_all_nodes_req(this), target, stream);
  }

  // .SSLSLCGetAllNodesRsp get_all_nodes_rsp = 8;
  if (_internal_has_get_all_nodes_rsp()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::get_all_nodes_rsp(this), target, stream);
  }

  // .SSLCLSGetLeastLoadNodeReq get_least_load_node_req = 9;
  if (_internal_has_get_least_load_node_req()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::get_least_load_node_req(this), target, stream);
  }

  // .SSLSLCGetLeastLoadNodeRsp get_least_load_node_rsp = 10;
  if (_internal_has_get_least_load_node_rsp()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::get_least_load_node_rsp(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SSLCLSPkgBody)
  return target;
}

size_t SSLCLSPkgBody::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SSLCLSPkgBody)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (body_case()) {
    // .SSLCLSNodeRegister node_register = 1;
    case kNodeRegister: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *body_.node_register_);
      break;
    }
    // .SSLCLSNodeUnregister node_unregister = 2;
    case kNodeUnregister: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *body_.node_unregister_);
      break;
    }
    // .SSLCLSHeartBeatReq heart_beat_req = 3;
    case kHeartBeatReq: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *body_.heart_beat_req_);
      break;
    }
    // .SSLSLCHeartBeatRsp heart_beat_rsp = 4;
    case kHeartBeatRsp: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *body_.heart_beat_rsp_);
      break;
    }
    // .SSLCLSSubscribe subscribe = 5;
    case kSubscribe: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *body_.subscribe_);
      break;
    }
    // .SSLSLCPublish publish = 6;
    case kPublish: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *body_.publish_);
      break;
    }
    // .SSLCLSGetAllNodesReq get_all_nodes_req = 7;
    case kGetAllNodesReq: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *body_.get_all_nodes_req_);
      break;
    }
    // .SSLSLCGetAllNodesRsp get_all_nodes_rsp = 8;
    case kGetAllNodesRsp: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *body_.get_all_nodes_rsp_);
      break;
    }
    // .SSLCLSGetLeastLoadNodeReq get_least_load_node_req = 9;
    case kGetLeastLoadNodeReq: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *body_.get_least_load_node_req_);
      break;
    }
    // .SSLSLCGetLeastLoadNodeRsp get_least_load_node_rsp = 10;
    case kGetLeastLoadNodeRsp: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *body_.get_least_load_node_rsp_);
      break;
    }
    case BODY_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SSLCLSPkgBody::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SSLCLSPkgBody::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SSLCLSPkgBody::GetClassData() const { return &_class_data_; }

void SSLCLSPkgBody::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SSLCLSPkgBody *>(to)->MergeFrom(
      static_cast<const SSLCLSPkgBody &>(from));
}


void SSLCLSPkgBody::MergeFrom(const SSLCLSPkgBody& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SSLCLSPkgBody)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.body_case()) {
    case kNodeRegister: {
      _internal_mutable_node_register()->::SSLCLSNodeRegister::MergeFrom(from._internal_node_register());
      break;
    }
    case kNodeUnregister: {
      _internal_mutable_node_unregister()->::SSLCLSNodeUnregister::MergeFrom(from._internal_node_unregister());
      break;
    }
    case kHeartBeatReq: {
      _internal_mutable_heart_beat_req()->::SSLCLSHeartBeatReq::MergeFrom(from._internal_heart_beat_req());
      break;
    }
    case kHeartBeatRsp: {
      _internal_mutable_heart_beat_rsp()->::SSLSLCHeartBeatRsp::MergeFrom(from._internal_heart_beat_rsp());
      break;
    }
    case kSubscribe: {
      _internal_mutable_subscribe()->::SSLCLSSubscribe::MergeFrom(from._internal_subscribe());
      break;
    }
    case kPublish: {
      _internal_mutable_publish()->::SSLSLCPublish::MergeFrom(from._internal_publish());
      break;
    }
    case kGetAllNodesReq: {
      _internal_mutable_get_all_nodes_req()->::SSLCLSGetAllNodesReq::MergeFrom(from._internal_get_all_nodes_req());
      break;
    }
    case kGetAllNodesRsp: {
      _internal_mutable_get_all_nodes_rsp()->::SSLSLCGetAllNodesRsp::MergeFrom(from._internal_get_all_nodes_rsp());
      break;
    }
    case kGetLeastLoadNodeReq: {
      _internal_mutable_get_least_load_node_req()->::SSLCLSGetLeastLoadNodeReq::MergeFrom(from._internal_get_least_load_node_req());
      break;
    }
    case kGetLeastLoadNodeRsp: {
      _internal_mutable_get_least_load_node_rsp()->::SSLSLCGetLeastLoadNodeRsp::MergeFrom(from._internal_get_least_load_node_rsp());
      break;
    }
    case BODY_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SSLCLSPkgBody::CopyFrom(const SSLCLSPkgBody& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SSLCLSPkgBody)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SSLCLSPkgBody::IsInitialized() const {
  return true;
}

void SSLCLSPkgBody::InternalSwap(SSLCLSPkgBody* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(body_, other->body_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata SSLCLSPkgBody::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_sslcls_2eproto_getter, &descriptor_table_sslcls_2eproto_once,
      file_level_metadata_sslcls_2eproto[11]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::SSLCLSNode* Arena::CreateMaybeMessage< ::SSLCLSNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SSLCLSNode >(arena);
}
template<> PROTOBUF_NOINLINE ::SSLCLSNodeRegister* Arena::CreateMaybeMessage< ::SSLCLSNodeRegister >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SSLCLSNodeRegister >(arena);
}
template<> PROTOBUF_NOINLINE ::SSLCLSNodeUnregister* Arena::CreateMaybeMessage< ::SSLCLSNodeUnregister >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SSLCLSNodeUnregister >(arena);
}
template<> PROTOBUF_NOINLINE ::SSLCLSHeartBeatReq* Arena::CreateMaybeMessage< ::SSLCLSHeartBeatReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SSLCLSHeartBeatReq >(arena);
}
template<> PROTOBUF_NOINLINE ::SSLSLCHeartBeatRsp* Arena::CreateMaybeMessage< ::SSLSLCHeartBeatRsp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SSLSLCHeartBeatRsp >(arena);
}
template<> PROTOBUF_NOINLINE ::SSLCLSSubscribe* Arena::CreateMaybeMessage< ::SSLCLSSubscribe >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SSLCLSSubscribe >(arena);
}
template<> PROTOBUF_NOINLINE ::SSLSLCPublish* Arena::CreateMaybeMessage< ::SSLSLCPublish >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SSLSLCPublish >(arena);
}
template<> PROTOBUF_NOINLINE ::SSLCLSGetAllNodesReq* Arena::CreateMaybeMessage< ::SSLCLSGetAllNodesReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SSLCLSGetAllNodesReq >(arena);
}
template<> PROTOBUF_NOINLINE ::SSLSLCGetAllNodesRsp* Arena::CreateMaybeMessage< ::SSLSLCGetAllNodesRsp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SSLSLCGetAllNodesRsp >(arena);
}
template<> PROTOBUF_NOINLINE ::SSLCLSGetLeastLoadNodeReq* Arena::CreateMaybeMessage< ::SSLCLSGetLeastLoadNodeReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SSLCLSGetLeastLoadNodeReq >(arena);
}
template<> PROTOBUF_NOINLINE ::SSLSLCGetLeastLoadNodeRsp* Arena::CreateMaybeMessage< ::SSLSLCGetLeastLoadNodeRsp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SSLSLCGetLeastLoadNodeRsp >(arena);
}
template<> PROTOBUF_NOINLINE ::SSLCLSPkgBody* Arena::CreateMaybeMessage< ::SSLCLSPkgBody >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SSLCLSPkgBody >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
