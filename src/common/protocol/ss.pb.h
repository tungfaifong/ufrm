// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ss.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ss_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ss_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
#include "ssid.pb.h"
#include "sslcls.pb.h"
#include "ssgwgs.pb.h"
#include "sspcpx.pb.h"
#include "ssdcds.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ss_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ss_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[3]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ss_2eproto;
class SSPkg;
struct SSPkgDefaultTypeInternal;
extern SSPkgDefaultTypeInternal _SSPkg_default_instance_;
class SSPkgBody;
struct SSPkgBodyDefaultTypeInternal;
extern SSPkgBodyDefaultTypeInternal _SSPkgBody_default_instance_;
class SSPkgHead;
struct SSPkgHeadDefaultTypeInternal;
extern SSPkgHeadDefaultTypeInternal _SSPkgHead_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::SSPkg* Arena::CreateMaybeMessage<::SSPkg>(Arena*);
template<> ::SSPkgBody* Arena::CreateMaybeMessage<::SSPkgBody>(Arena*);
template<> ::SSPkgHead* Arena::CreateMaybeMessage<::SSPkgHead>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum SSPkgHead_MSGTYPE : int {
  SSPkgHead_MSGTYPE_NORMAL = 0,
  SSPkgHead_MSGTYPE_RPCREQ = 1,
  SSPkgHead_MSGTYPE_RPCRSP = 2,
  SSPkgHead_MSGTYPE_SSPkgHead_MSGTYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SSPkgHead_MSGTYPE_SSPkgHead_MSGTYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SSPkgHead_MSGTYPE_IsValid(int value);
constexpr SSPkgHead_MSGTYPE SSPkgHead_MSGTYPE_MSGTYPE_MIN = SSPkgHead_MSGTYPE_NORMAL;
constexpr SSPkgHead_MSGTYPE SSPkgHead_MSGTYPE_MSGTYPE_MAX = SSPkgHead_MSGTYPE_RPCRSP;
constexpr int SSPkgHead_MSGTYPE_MSGTYPE_ARRAYSIZE = SSPkgHead_MSGTYPE_MSGTYPE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SSPkgHead_MSGTYPE_descriptor();
template<typename T>
inline const std::string& SSPkgHead_MSGTYPE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SSPkgHead_MSGTYPE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SSPkgHead_MSGTYPE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SSPkgHead_MSGTYPE_descriptor(), enum_t_value);
}
inline bool SSPkgHead_MSGTYPE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SSPkgHead_MSGTYPE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SSPkgHead_MSGTYPE>(
    SSPkgHead_MSGTYPE_descriptor(), name, value);
}
enum SSPkgHead_PROXYTYPE : int {
  SSPkgHead_PROXYTYPE_END = 0,
  SSPkgHead_PROXYTYPE_FORWARD = 1,
  SSPkgHead_PROXYTYPE_BROADCAST = 2,
  SSPkgHead_PROXYTYPE_SSPkgHead_PROXYTYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SSPkgHead_PROXYTYPE_SSPkgHead_PROXYTYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SSPkgHead_PROXYTYPE_IsValid(int value);
constexpr SSPkgHead_PROXYTYPE SSPkgHead_PROXYTYPE_PROXYTYPE_MIN = SSPkgHead_PROXYTYPE_END;
constexpr SSPkgHead_PROXYTYPE SSPkgHead_PROXYTYPE_PROXYTYPE_MAX = SSPkgHead_PROXYTYPE_BROADCAST;
constexpr int SSPkgHead_PROXYTYPE_PROXYTYPE_ARRAYSIZE = SSPkgHead_PROXYTYPE_PROXYTYPE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SSPkgHead_PROXYTYPE_descriptor();
template<typename T>
inline const std::string& SSPkgHead_PROXYTYPE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SSPkgHead_PROXYTYPE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SSPkgHead_PROXYTYPE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SSPkgHead_PROXYTYPE_descriptor(), enum_t_value);
}
inline bool SSPkgHead_PROXYTYPE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SSPkgHead_PROXYTYPE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SSPkgHead_PROXYTYPE>(
    SSPkgHead_PROXYTYPE_descriptor(), name, value);
}
enum SSPkgHead_LOGICTYPE : int {
  SSPkgHead_LOGICTYPE_BOTH = 0,
  SSPkgHead_LOGICTYPE_CPP = 1,
  SSPkgHead_LOGICTYPE_LUA = 2,
  SSPkgHead_LOGICTYPE_SSPkgHead_LOGICTYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SSPkgHead_LOGICTYPE_SSPkgHead_LOGICTYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SSPkgHead_LOGICTYPE_IsValid(int value);
constexpr SSPkgHead_LOGICTYPE SSPkgHead_LOGICTYPE_LOGICTYPE_MIN = SSPkgHead_LOGICTYPE_BOTH;
constexpr SSPkgHead_LOGICTYPE SSPkgHead_LOGICTYPE_LOGICTYPE_MAX = SSPkgHead_LOGICTYPE_LUA;
constexpr int SSPkgHead_LOGICTYPE_LOGICTYPE_ARRAYSIZE = SSPkgHead_LOGICTYPE_LOGICTYPE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SSPkgHead_LOGICTYPE_descriptor();
template<typename T>
inline const std::string& SSPkgHead_LOGICTYPE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SSPkgHead_LOGICTYPE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SSPkgHead_LOGICTYPE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SSPkgHead_LOGICTYPE_descriptor(), enum_t_value);
}
inline bool SSPkgHead_LOGICTYPE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SSPkgHead_LOGICTYPE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SSPkgHead_LOGICTYPE>(
    SSPkgHead_LOGICTYPE_descriptor(), name, value);
}
// ===================================================================

class SSPkgHead final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SSPkgHead) */ {
 public:
  inline SSPkgHead() : SSPkgHead(nullptr) {}
  ~SSPkgHead() override;
  explicit constexpr SSPkgHead(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SSPkgHead(const SSPkgHead& from);
  SSPkgHead(SSPkgHead&& from) noexcept
    : SSPkgHead() {
    *this = ::std::move(from);
  }

  inline SSPkgHead& operator=(const SSPkgHead& from) {
    CopyFrom(from);
    return *this;
  }
  inline SSPkgHead& operator=(SSPkgHead&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SSPkgHead& default_instance() {
    return *internal_default_instance();
  }
  static inline const SSPkgHead* internal_default_instance() {
    return reinterpret_cast<const SSPkgHead*>(
               &_SSPkgHead_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SSPkgHead& a, SSPkgHead& b) {
    a.Swap(&b);
  }
  inline void Swap(SSPkgHead* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SSPkgHead* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SSPkgHead* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SSPkgHead>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SSPkgHead& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SSPkgHead& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SSPkgHead* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SSPkgHead";
  }
  protected:
  explicit SSPkgHead(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SSPkgHead_MSGTYPE MSGTYPE;
  static constexpr MSGTYPE NORMAL =
    SSPkgHead_MSGTYPE_NORMAL;
  static constexpr MSGTYPE RPCREQ =
    SSPkgHead_MSGTYPE_RPCREQ;
  static constexpr MSGTYPE RPCRSP =
    SSPkgHead_MSGTYPE_RPCRSP;
  static inline bool MSGTYPE_IsValid(int value) {
    return SSPkgHead_MSGTYPE_IsValid(value);
  }
  static constexpr MSGTYPE MSGTYPE_MIN =
    SSPkgHead_MSGTYPE_MSGTYPE_MIN;
  static constexpr MSGTYPE MSGTYPE_MAX =
    SSPkgHead_MSGTYPE_MSGTYPE_MAX;
  static constexpr int MSGTYPE_ARRAYSIZE =
    SSPkgHead_MSGTYPE_MSGTYPE_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MSGTYPE_descriptor() {
    return SSPkgHead_MSGTYPE_descriptor();
  }
  template<typename T>
  static inline const std::string& MSGTYPE_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MSGTYPE>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MSGTYPE_Name.");
    return SSPkgHead_MSGTYPE_Name(enum_t_value);
  }
  static inline bool MSGTYPE_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MSGTYPE* value) {
    return SSPkgHead_MSGTYPE_Parse(name, value);
  }

  typedef SSPkgHead_PROXYTYPE PROXYTYPE;
  static constexpr PROXYTYPE END =
    SSPkgHead_PROXYTYPE_END;
  static constexpr PROXYTYPE FORWARD =
    SSPkgHead_PROXYTYPE_FORWARD;
  static constexpr PROXYTYPE BROADCAST =
    SSPkgHead_PROXYTYPE_BROADCAST;
  static inline bool PROXYTYPE_IsValid(int value) {
    return SSPkgHead_PROXYTYPE_IsValid(value);
  }
  static constexpr PROXYTYPE PROXYTYPE_MIN =
    SSPkgHead_PROXYTYPE_PROXYTYPE_MIN;
  static constexpr PROXYTYPE PROXYTYPE_MAX =
    SSPkgHead_PROXYTYPE_PROXYTYPE_MAX;
  static constexpr int PROXYTYPE_ARRAYSIZE =
    SSPkgHead_PROXYTYPE_PROXYTYPE_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PROXYTYPE_descriptor() {
    return SSPkgHead_PROXYTYPE_descriptor();
  }
  template<typename T>
  static inline const std::string& PROXYTYPE_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PROXYTYPE>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PROXYTYPE_Name.");
    return SSPkgHead_PROXYTYPE_Name(enum_t_value);
  }
  static inline bool PROXYTYPE_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PROXYTYPE* value) {
    return SSPkgHead_PROXYTYPE_Parse(name, value);
  }

  typedef SSPkgHead_LOGICTYPE LOGICTYPE;
  static constexpr LOGICTYPE BOTH =
    SSPkgHead_LOGICTYPE_BOTH;
  static constexpr LOGICTYPE CPP =
    SSPkgHead_LOGICTYPE_CPP;
  static constexpr LOGICTYPE LUA =
    SSPkgHead_LOGICTYPE_LUA;
  static inline bool LOGICTYPE_IsValid(int value) {
    return SSPkgHead_LOGICTYPE_IsValid(value);
  }
  static constexpr LOGICTYPE LOGICTYPE_MIN =
    SSPkgHead_LOGICTYPE_LOGICTYPE_MIN;
  static constexpr LOGICTYPE LOGICTYPE_MAX =
    SSPkgHead_LOGICTYPE_LOGICTYPE_MAX;
  static constexpr int LOGICTYPE_ARRAYSIZE =
    SSPkgHead_LOGICTYPE_LOGICTYPE_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LOGICTYPE_descriptor() {
    return SSPkgHead_LOGICTYPE_descriptor();
  }
  template<typename T>
  static inline const std::string& LOGICTYPE_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LOGICTYPE>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LOGICTYPE_Name.");
    return SSPkgHead_LOGICTYPE_Name(enum_t_value);
  }
  static inline bool LOGICTYPE_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LOGICTYPE* value) {
    return SSPkgHead_LOGICTYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFromNodeTypeFieldNumber = 1,
    kFromNodeIdFieldNumber = 2,
    kToNodeTypeFieldNumber = 3,
    kToNodeIdFieldNumber = 4,
    kIdFieldNumber = 5,
    kMsgTypeFieldNumber = 6,
    kRpcIdFieldNumber = 7,
    kProxyTypeFieldNumber = 8,
    kLogicTypeFieldNumber = 9,
  };
  // .NODETYPE from_node_type = 1;
  void clear_from_node_type();
  ::NODETYPE from_node_type() const;
  void set_from_node_type(::NODETYPE value);
  private:
  ::NODETYPE _internal_from_node_type() const;
  void _internal_set_from_node_type(::NODETYPE value);
  public:

  // uint32 from_node_id = 2;
  void clear_from_node_id();
  uint32_t from_node_id() const;
  void set_from_node_id(uint32_t value);
  private:
  uint32_t _internal_from_node_id() const;
  void _internal_set_from_node_id(uint32_t value);
  public:

  // .NODETYPE to_node_type = 3;
  void clear_to_node_type();
  ::NODETYPE to_node_type() const;
  void set_to_node_type(::NODETYPE value);
  private:
  ::NODETYPE _internal_to_node_type() const;
  void _internal_set_to_node_type(::NODETYPE value);
  public:

  // uint32 to_node_id = 4;
  void clear_to_node_id();
  uint32_t to_node_id() const;
  void set_to_node_id(uint32_t value);
  private:
  uint32_t _internal_to_node_id() const;
  void _internal_set_to_node_id(uint32_t value);
  public:

  // .SSID id = 5;
  void clear_id();
  ::SSID id() const;
  void set_id(::SSID value);
  private:
  ::SSID _internal_id() const;
  void _internal_set_id(::SSID value);
  public:

  // .SSPkgHead.MSGTYPE msg_type = 6;
  void clear_msg_type();
  ::SSPkgHead_MSGTYPE msg_type() const;
  void set_msg_type(::SSPkgHead_MSGTYPE value);
  private:
  ::SSPkgHead_MSGTYPE _internal_msg_type() const;
  void _internal_set_msg_type(::SSPkgHead_MSGTYPE value);
  public:

  // uint64 rpc_id = 7;
  void clear_rpc_id();
  uint64_t rpc_id() const;
  void set_rpc_id(uint64_t value);
  private:
  uint64_t _internal_rpc_id() const;
  void _internal_set_rpc_id(uint64_t value);
  public:

  // .SSPkgHead.PROXYTYPE proxy_type = 8;
  void clear_proxy_type();
  ::SSPkgHead_PROXYTYPE proxy_type() const;
  void set_proxy_type(::SSPkgHead_PROXYTYPE value);
  private:
  ::SSPkgHead_PROXYTYPE _internal_proxy_type() const;
  void _internal_set_proxy_type(::SSPkgHead_PROXYTYPE value);
  public:

  // .SSPkgHead.LOGICTYPE logic_type = 9;
  void clear_logic_type();
  ::SSPkgHead_LOGICTYPE logic_type() const;
  void set_logic_type(::SSPkgHead_LOGICTYPE value);
  private:
  ::SSPkgHead_LOGICTYPE _internal_logic_type() const;
  void _internal_set_logic_type(::SSPkgHead_LOGICTYPE value);
  public:

  // @@protoc_insertion_point(class_scope:SSPkgHead)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int from_node_type_;
  uint32_t from_node_id_;
  int to_node_type_;
  uint32_t to_node_id_;
  int id_;
  int msg_type_;
  uint64_t rpc_id_;
  int proxy_type_;
  int logic_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ss_2eproto;
};
// -------------------------------------------------------------------

class SSPkgBody final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SSPkgBody) */ {
 public:
  inline SSPkgBody() : SSPkgBody(nullptr) {}
  ~SSPkgBody() override;
  explicit constexpr SSPkgBody(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SSPkgBody(const SSPkgBody& from);
  SSPkgBody(SSPkgBody&& from) noexcept
    : SSPkgBody() {
    *this = ::std::move(from);
  }

  inline SSPkgBody& operator=(const SSPkgBody& from) {
    CopyFrom(from);
    return *this;
  }
  inline SSPkgBody& operator=(SSPkgBody&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SSPkgBody& default_instance() {
    return *internal_default_instance();
  }
  enum BodyCase {
    kLclsBody = 1,
    kGwgsBody = 2,
    kPcpxBody = 3,
    kDcdsBody = 4,
    BODY_NOT_SET = 0,
  };

  static inline const SSPkgBody* internal_default_instance() {
    return reinterpret_cast<const SSPkgBody*>(
               &_SSPkgBody_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SSPkgBody& a, SSPkgBody& b) {
    a.Swap(&b);
  }
  inline void Swap(SSPkgBody* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SSPkgBody* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SSPkgBody* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SSPkgBody>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SSPkgBody& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SSPkgBody& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SSPkgBody* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SSPkgBody";
  }
  protected:
  explicit SSPkgBody(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLclsBodyFieldNumber = 1,
    kGwgsBodyFieldNumber = 2,
    kPcpxBodyFieldNumber = 3,
    kDcdsBodyFieldNumber = 4,
  };
  // .SSLCLSPkgBody lcls_body = 1;
  bool has_lcls_body() const;
  private:
  bool _internal_has_lcls_body() const;
  public:
  void clear_lcls_body();
  const ::SSLCLSPkgBody& lcls_body() const;
  PROTOBUF_NODISCARD ::SSLCLSPkgBody* release_lcls_body();
  ::SSLCLSPkgBody* mutable_lcls_body();
  void set_allocated_lcls_body(::SSLCLSPkgBody* lcls_body);
  private:
  const ::SSLCLSPkgBody& _internal_lcls_body() const;
  ::SSLCLSPkgBody* _internal_mutable_lcls_body();
  public:
  void unsafe_arena_set_allocated_lcls_body(
      ::SSLCLSPkgBody* lcls_body);
  ::SSLCLSPkgBody* unsafe_arena_release_lcls_body();

  // .SSGWGSPkgBody gwgs_body = 2;
  bool has_gwgs_body() const;
  private:
  bool _internal_has_gwgs_body() const;
  public:
  void clear_gwgs_body();
  const ::SSGWGSPkgBody& gwgs_body() const;
  PROTOBUF_NODISCARD ::SSGWGSPkgBody* release_gwgs_body();
  ::SSGWGSPkgBody* mutable_gwgs_body();
  void set_allocated_gwgs_body(::SSGWGSPkgBody* gwgs_body);
  private:
  const ::SSGWGSPkgBody& _internal_gwgs_body() const;
  ::SSGWGSPkgBody* _internal_mutable_gwgs_body();
  public:
  void unsafe_arena_set_allocated_gwgs_body(
      ::SSGWGSPkgBody* gwgs_body);
  ::SSGWGSPkgBody* unsafe_arena_release_gwgs_body();

  // .SSPCPXPkgBody pcpx_body = 3;
  bool has_pcpx_body() const;
  private:
  bool _internal_has_pcpx_body() const;
  public:
  void clear_pcpx_body();
  const ::SSPCPXPkgBody& pcpx_body() const;
  PROTOBUF_NODISCARD ::SSPCPXPkgBody* release_pcpx_body();
  ::SSPCPXPkgBody* mutable_pcpx_body();
  void set_allocated_pcpx_body(::SSPCPXPkgBody* pcpx_body);
  private:
  const ::SSPCPXPkgBody& _internal_pcpx_body() const;
  ::SSPCPXPkgBody* _internal_mutable_pcpx_body();
  public:
  void unsafe_arena_set_allocated_pcpx_body(
      ::SSPCPXPkgBody* pcpx_body);
  ::SSPCPXPkgBody* unsafe_arena_release_pcpx_body();

  // .SSDCDSPkgBody dcds_body = 4;
  bool has_dcds_body() const;
  private:
  bool _internal_has_dcds_body() const;
  public:
  void clear_dcds_body();
  const ::SSDCDSPkgBody& dcds_body() const;
  PROTOBUF_NODISCARD ::SSDCDSPkgBody* release_dcds_body();
  ::SSDCDSPkgBody* mutable_dcds_body();
  void set_allocated_dcds_body(::SSDCDSPkgBody* dcds_body);
  private:
  const ::SSDCDSPkgBody& _internal_dcds_body() const;
  ::SSDCDSPkgBody* _internal_mutable_dcds_body();
  public:
  void unsafe_arena_set_allocated_dcds_body(
      ::SSDCDSPkgBody* dcds_body);
  ::SSDCDSPkgBody* unsafe_arena_release_dcds_body();

  void clear_body();
  BodyCase body_case() const;
  // @@protoc_insertion_point(class_scope:SSPkgBody)
 private:
  class _Internal;
  void set_has_lcls_body();
  void set_has_gwgs_body();
  void set_has_pcpx_body();
  void set_has_dcds_body();

  inline bool has_body() const;
  inline void clear_has_body();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union BodyUnion {
    constexpr BodyUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::SSLCLSPkgBody* lcls_body_;
    ::SSGWGSPkgBody* gwgs_body_;
    ::SSPCPXPkgBody* pcpx_body_;
    ::SSDCDSPkgBody* dcds_body_;
  } body_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_ss_2eproto;
};
// -------------------------------------------------------------------

class SSPkg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SSPkg) */ {
 public:
  inline SSPkg() : SSPkg(nullptr) {}
  ~SSPkg() override;
  explicit constexpr SSPkg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SSPkg(const SSPkg& from);
  SSPkg(SSPkg&& from) noexcept
    : SSPkg() {
    *this = ::std::move(from);
  }

  inline SSPkg& operator=(const SSPkg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SSPkg& operator=(SSPkg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SSPkg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SSPkg* internal_default_instance() {
    return reinterpret_cast<const SSPkg*>(
               &_SSPkg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SSPkg& a, SSPkg& b) {
    a.Swap(&b);
  }
  inline void Swap(SSPkg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SSPkg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SSPkg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SSPkg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SSPkg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SSPkg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SSPkg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SSPkg";
  }
  protected:
  explicit SSPkg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeadFieldNumber = 1,
    kBodyFieldNumber = 2,
  };
  // .SSPkgHead head = 1;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::SSPkgHead& head() const;
  PROTOBUF_NODISCARD ::SSPkgHead* release_head();
  ::SSPkgHead* mutable_head();
  void set_allocated_head(::SSPkgHead* head);
  private:
  const ::SSPkgHead& _internal_head() const;
  ::SSPkgHead* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::SSPkgHead* head);
  ::SSPkgHead* unsafe_arena_release_head();

  // .SSPkgBody body = 2;
  bool has_body() const;
  private:
  bool _internal_has_body() const;
  public:
  void clear_body();
  const ::SSPkgBody& body() const;
  PROTOBUF_NODISCARD ::SSPkgBody* release_body();
  ::SSPkgBody* mutable_body();
  void set_allocated_body(::SSPkgBody* body);
  private:
  const ::SSPkgBody& _internal_body() const;
  ::SSPkgBody* _internal_mutable_body();
  public:
  void unsafe_arena_set_allocated_body(
      ::SSPkgBody* body);
  ::SSPkgBody* unsafe_arena_release_body();

  // @@protoc_insertion_point(class_scope:SSPkg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::SSPkgHead* head_;
  ::SSPkgBody* body_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ss_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SSPkgHead

// .NODETYPE from_node_type = 1;
inline void SSPkgHead::clear_from_node_type() {
  from_node_type_ = 0;
}
inline ::NODETYPE SSPkgHead::_internal_from_node_type() const {
  return static_cast< ::NODETYPE >(from_node_type_);
}
inline ::NODETYPE SSPkgHead::from_node_type() const {
  // @@protoc_insertion_point(field_get:SSPkgHead.from_node_type)
  return _internal_from_node_type();
}
inline void SSPkgHead::_internal_set_from_node_type(::NODETYPE value) {
  
  from_node_type_ = value;
}
inline void SSPkgHead::set_from_node_type(::NODETYPE value) {
  _internal_set_from_node_type(value);
  // @@protoc_insertion_point(field_set:SSPkgHead.from_node_type)
}

// uint32 from_node_id = 2;
inline void SSPkgHead::clear_from_node_id() {
  from_node_id_ = 0u;
}
inline uint32_t SSPkgHead::_internal_from_node_id() const {
  return from_node_id_;
}
inline uint32_t SSPkgHead::from_node_id() const {
  // @@protoc_insertion_point(field_get:SSPkgHead.from_node_id)
  return _internal_from_node_id();
}
inline void SSPkgHead::_internal_set_from_node_id(uint32_t value) {
  
  from_node_id_ = value;
}
inline void SSPkgHead::set_from_node_id(uint32_t value) {
  _internal_set_from_node_id(value);
  // @@protoc_insertion_point(field_set:SSPkgHead.from_node_id)
}

// .NODETYPE to_node_type = 3;
inline void SSPkgHead::clear_to_node_type() {
  to_node_type_ = 0;
}
inline ::NODETYPE SSPkgHead::_internal_to_node_type() const {
  return static_cast< ::NODETYPE >(to_node_type_);
}
inline ::NODETYPE SSPkgHead::to_node_type() const {
  // @@protoc_insertion_point(field_get:SSPkgHead.to_node_type)
  return _internal_to_node_type();
}
inline void SSPkgHead::_internal_set_to_node_type(::NODETYPE value) {
  
  to_node_type_ = value;
}
inline void SSPkgHead::set_to_node_type(::NODETYPE value) {
  _internal_set_to_node_type(value);
  // @@protoc_insertion_point(field_set:SSPkgHead.to_node_type)
}

// uint32 to_node_id = 4;
inline void SSPkgHead::clear_to_node_id() {
  to_node_id_ = 0u;
}
inline uint32_t SSPkgHead::_internal_to_node_id() const {
  return to_node_id_;
}
inline uint32_t SSPkgHead::to_node_id() const {
  // @@protoc_insertion_point(field_get:SSPkgHead.to_node_id)
  return _internal_to_node_id();
}
inline void SSPkgHead::_internal_set_to_node_id(uint32_t value) {
  
  to_node_id_ = value;
}
inline void SSPkgHead::set_to_node_id(uint32_t value) {
  _internal_set_to_node_id(value);
  // @@protoc_insertion_point(field_set:SSPkgHead.to_node_id)
}

// .SSID id = 5;
inline void SSPkgHead::clear_id() {
  id_ = 0;
}
inline ::SSID SSPkgHead::_internal_id() const {
  return static_cast< ::SSID >(id_);
}
inline ::SSID SSPkgHead::id() const {
  // @@protoc_insertion_point(field_get:SSPkgHead.id)
  return _internal_id();
}
inline void SSPkgHead::_internal_set_id(::SSID value) {
  
  id_ = value;
}
inline void SSPkgHead::set_id(::SSID value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:SSPkgHead.id)
}

// .SSPkgHead.MSGTYPE msg_type = 6;
inline void SSPkgHead::clear_msg_type() {
  msg_type_ = 0;
}
inline ::SSPkgHead_MSGTYPE SSPkgHead::_internal_msg_type() const {
  return static_cast< ::SSPkgHead_MSGTYPE >(msg_type_);
}
inline ::SSPkgHead_MSGTYPE SSPkgHead::msg_type() const {
  // @@protoc_insertion_point(field_get:SSPkgHead.msg_type)
  return _internal_msg_type();
}
inline void SSPkgHead::_internal_set_msg_type(::SSPkgHead_MSGTYPE value) {
  
  msg_type_ = value;
}
inline void SSPkgHead::set_msg_type(::SSPkgHead_MSGTYPE value) {
  _internal_set_msg_type(value);
  // @@protoc_insertion_point(field_set:SSPkgHead.msg_type)
}

// uint64 rpc_id = 7;
inline void SSPkgHead::clear_rpc_id() {
  rpc_id_ = uint64_t{0u};
}
inline uint64_t SSPkgHead::_internal_rpc_id() const {
  return rpc_id_;
}
inline uint64_t SSPkgHead::rpc_id() const {
  // @@protoc_insertion_point(field_get:SSPkgHead.rpc_id)
  return _internal_rpc_id();
}
inline void SSPkgHead::_internal_set_rpc_id(uint64_t value) {
  
  rpc_id_ = value;
}
inline void SSPkgHead::set_rpc_id(uint64_t value) {
  _internal_set_rpc_id(value);
  // @@protoc_insertion_point(field_set:SSPkgHead.rpc_id)
}

// .SSPkgHead.PROXYTYPE proxy_type = 8;
inline void SSPkgHead::clear_proxy_type() {
  proxy_type_ = 0;
}
inline ::SSPkgHead_PROXYTYPE SSPkgHead::_internal_proxy_type() const {
  return static_cast< ::SSPkgHead_PROXYTYPE >(proxy_type_);
}
inline ::SSPkgHead_PROXYTYPE SSPkgHead::proxy_type() const {
  // @@protoc_insertion_point(field_get:SSPkgHead.proxy_type)
  return _internal_proxy_type();
}
inline void SSPkgHead::_internal_set_proxy_type(::SSPkgHead_PROXYTYPE value) {
  
  proxy_type_ = value;
}
inline void SSPkgHead::set_proxy_type(::SSPkgHead_PROXYTYPE value) {
  _internal_set_proxy_type(value);
  // @@protoc_insertion_point(field_set:SSPkgHead.proxy_type)
}

// .SSPkgHead.LOGICTYPE logic_type = 9;
inline void SSPkgHead::clear_logic_type() {
  logic_type_ = 0;
}
inline ::SSPkgHead_LOGICTYPE SSPkgHead::_internal_logic_type() const {
  return static_cast< ::SSPkgHead_LOGICTYPE >(logic_type_);
}
inline ::SSPkgHead_LOGICTYPE SSPkgHead::logic_type() const {
  // @@protoc_insertion_point(field_get:SSPkgHead.logic_type)
  return _internal_logic_type();
}
inline void SSPkgHead::_internal_set_logic_type(::SSPkgHead_LOGICTYPE value) {
  
  logic_type_ = value;
}
inline void SSPkgHead::set_logic_type(::SSPkgHead_LOGICTYPE value) {
  _internal_set_logic_type(value);
  // @@protoc_insertion_point(field_set:SSPkgHead.logic_type)
}

// -------------------------------------------------------------------

// SSPkgBody

// .SSLCLSPkgBody lcls_body = 1;
inline bool SSPkgBody::_internal_has_lcls_body() const {
  return body_case() == kLclsBody;
}
inline bool SSPkgBody::has_lcls_body() const {
  return _internal_has_lcls_body();
}
inline void SSPkgBody::set_has_lcls_body() {
  _oneof_case_[0] = kLclsBody;
}
inline ::SSLCLSPkgBody* SSPkgBody::release_lcls_body() {
  // @@protoc_insertion_point(field_release:SSPkgBody.lcls_body)
  if (_internal_has_lcls_body()) {
    clear_has_body();
      ::SSLCLSPkgBody* temp = body_.lcls_body_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    body_.lcls_body_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SSLCLSPkgBody& SSPkgBody::_internal_lcls_body() const {
  return _internal_has_lcls_body()
      ? *body_.lcls_body_
      : reinterpret_cast< ::SSLCLSPkgBody&>(::_SSLCLSPkgBody_default_instance_);
}
inline const ::SSLCLSPkgBody& SSPkgBody::lcls_body() const {
  // @@protoc_insertion_point(field_get:SSPkgBody.lcls_body)
  return _internal_lcls_body();
}
inline ::SSLCLSPkgBody* SSPkgBody::unsafe_arena_release_lcls_body() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SSPkgBody.lcls_body)
  if (_internal_has_lcls_body()) {
    clear_has_body();
    ::SSLCLSPkgBody* temp = body_.lcls_body_;
    body_.lcls_body_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SSPkgBody::unsafe_arena_set_allocated_lcls_body(::SSLCLSPkgBody* lcls_body) {
  clear_body();
  if (lcls_body) {
    set_has_lcls_body();
    body_.lcls_body_ = lcls_body;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SSPkgBody.lcls_body)
}
inline ::SSLCLSPkgBody* SSPkgBody::_internal_mutable_lcls_body() {
  if (!_internal_has_lcls_body()) {
    clear_body();
    set_has_lcls_body();
    body_.lcls_body_ = CreateMaybeMessage< ::SSLCLSPkgBody >(GetArenaForAllocation());
  }
  return body_.lcls_body_;
}
inline ::SSLCLSPkgBody* SSPkgBody::mutable_lcls_body() {
  ::SSLCLSPkgBody* _msg = _internal_mutable_lcls_body();
  // @@protoc_insertion_point(field_mutable:SSPkgBody.lcls_body)
  return _msg;
}

// .SSGWGSPkgBody gwgs_body = 2;
inline bool SSPkgBody::_internal_has_gwgs_body() const {
  return body_case() == kGwgsBody;
}
inline bool SSPkgBody::has_gwgs_body() const {
  return _internal_has_gwgs_body();
}
inline void SSPkgBody::set_has_gwgs_body() {
  _oneof_case_[0] = kGwgsBody;
}
inline ::SSGWGSPkgBody* SSPkgBody::release_gwgs_body() {
  // @@protoc_insertion_point(field_release:SSPkgBody.gwgs_body)
  if (_internal_has_gwgs_body()) {
    clear_has_body();
      ::SSGWGSPkgBody* temp = body_.gwgs_body_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    body_.gwgs_body_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SSGWGSPkgBody& SSPkgBody::_internal_gwgs_body() const {
  return _internal_has_gwgs_body()
      ? *body_.gwgs_body_
      : reinterpret_cast< ::SSGWGSPkgBody&>(::_SSGWGSPkgBody_default_instance_);
}
inline const ::SSGWGSPkgBody& SSPkgBody::gwgs_body() const {
  // @@protoc_insertion_point(field_get:SSPkgBody.gwgs_body)
  return _internal_gwgs_body();
}
inline ::SSGWGSPkgBody* SSPkgBody::unsafe_arena_release_gwgs_body() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SSPkgBody.gwgs_body)
  if (_internal_has_gwgs_body()) {
    clear_has_body();
    ::SSGWGSPkgBody* temp = body_.gwgs_body_;
    body_.gwgs_body_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SSPkgBody::unsafe_arena_set_allocated_gwgs_body(::SSGWGSPkgBody* gwgs_body) {
  clear_body();
  if (gwgs_body) {
    set_has_gwgs_body();
    body_.gwgs_body_ = gwgs_body;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SSPkgBody.gwgs_body)
}
inline ::SSGWGSPkgBody* SSPkgBody::_internal_mutable_gwgs_body() {
  if (!_internal_has_gwgs_body()) {
    clear_body();
    set_has_gwgs_body();
    body_.gwgs_body_ = CreateMaybeMessage< ::SSGWGSPkgBody >(GetArenaForAllocation());
  }
  return body_.gwgs_body_;
}
inline ::SSGWGSPkgBody* SSPkgBody::mutable_gwgs_body() {
  ::SSGWGSPkgBody* _msg = _internal_mutable_gwgs_body();
  // @@protoc_insertion_point(field_mutable:SSPkgBody.gwgs_body)
  return _msg;
}

// .SSPCPXPkgBody pcpx_body = 3;
inline bool SSPkgBody::_internal_has_pcpx_body() const {
  return body_case() == kPcpxBody;
}
inline bool SSPkgBody::has_pcpx_body() const {
  return _internal_has_pcpx_body();
}
inline void SSPkgBody::set_has_pcpx_body() {
  _oneof_case_[0] = kPcpxBody;
}
inline ::SSPCPXPkgBody* SSPkgBody::release_pcpx_body() {
  // @@protoc_insertion_point(field_release:SSPkgBody.pcpx_body)
  if (_internal_has_pcpx_body()) {
    clear_has_body();
      ::SSPCPXPkgBody* temp = body_.pcpx_body_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    body_.pcpx_body_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SSPCPXPkgBody& SSPkgBody::_internal_pcpx_body() const {
  return _internal_has_pcpx_body()
      ? *body_.pcpx_body_
      : reinterpret_cast< ::SSPCPXPkgBody&>(::_SSPCPXPkgBody_default_instance_);
}
inline const ::SSPCPXPkgBody& SSPkgBody::pcpx_body() const {
  // @@protoc_insertion_point(field_get:SSPkgBody.pcpx_body)
  return _internal_pcpx_body();
}
inline ::SSPCPXPkgBody* SSPkgBody::unsafe_arena_release_pcpx_body() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SSPkgBody.pcpx_body)
  if (_internal_has_pcpx_body()) {
    clear_has_body();
    ::SSPCPXPkgBody* temp = body_.pcpx_body_;
    body_.pcpx_body_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SSPkgBody::unsafe_arena_set_allocated_pcpx_body(::SSPCPXPkgBody* pcpx_body) {
  clear_body();
  if (pcpx_body) {
    set_has_pcpx_body();
    body_.pcpx_body_ = pcpx_body;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SSPkgBody.pcpx_body)
}
inline ::SSPCPXPkgBody* SSPkgBody::_internal_mutable_pcpx_body() {
  if (!_internal_has_pcpx_body()) {
    clear_body();
    set_has_pcpx_body();
    body_.pcpx_body_ = CreateMaybeMessage< ::SSPCPXPkgBody >(GetArenaForAllocation());
  }
  return body_.pcpx_body_;
}
inline ::SSPCPXPkgBody* SSPkgBody::mutable_pcpx_body() {
  ::SSPCPXPkgBody* _msg = _internal_mutable_pcpx_body();
  // @@protoc_insertion_point(field_mutable:SSPkgBody.pcpx_body)
  return _msg;
}

// .SSDCDSPkgBody dcds_body = 4;
inline bool SSPkgBody::_internal_has_dcds_body() const {
  return body_case() == kDcdsBody;
}
inline bool SSPkgBody::has_dcds_body() const {
  return _internal_has_dcds_body();
}
inline void SSPkgBody::set_has_dcds_body() {
  _oneof_case_[0] = kDcdsBody;
}
inline ::SSDCDSPkgBody* SSPkgBody::release_dcds_body() {
  // @@protoc_insertion_point(field_release:SSPkgBody.dcds_body)
  if (_internal_has_dcds_body()) {
    clear_has_body();
      ::SSDCDSPkgBody* temp = body_.dcds_body_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    body_.dcds_body_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SSDCDSPkgBody& SSPkgBody::_internal_dcds_body() const {
  return _internal_has_dcds_body()
      ? *body_.dcds_body_
      : reinterpret_cast< ::SSDCDSPkgBody&>(::_SSDCDSPkgBody_default_instance_);
}
inline const ::SSDCDSPkgBody& SSPkgBody::dcds_body() const {
  // @@protoc_insertion_point(field_get:SSPkgBody.dcds_body)
  return _internal_dcds_body();
}
inline ::SSDCDSPkgBody* SSPkgBody::unsafe_arena_release_dcds_body() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SSPkgBody.dcds_body)
  if (_internal_has_dcds_body()) {
    clear_has_body();
    ::SSDCDSPkgBody* temp = body_.dcds_body_;
    body_.dcds_body_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SSPkgBody::unsafe_arena_set_allocated_dcds_body(::SSDCDSPkgBody* dcds_body) {
  clear_body();
  if (dcds_body) {
    set_has_dcds_body();
    body_.dcds_body_ = dcds_body;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SSPkgBody.dcds_body)
}
inline ::SSDCDSPkgBody* SSPkgBody::_internal_mutable_dcds_body() {
  if (!_internal_has_dcds_body()) {
    clear_body();
    set_has_dcds_body();
    body_.dcds_body_ = CreateMaybeMessage< ::SSDCDSPkgBody >(GetArenaForAllocation());
  }
  return body_.dcds_body_;
}
inline ::SSDCDSPkgBody* SSPkgBody::mutable_dcds_body() {
  ::SSDCDSPkgBody* _msg = _internal_mutable_dcds_body();
  // @@protoc_insertion_point(field_mutable:SSPkgBody.dcds_body)
  return _msg;
}

inline bool SSPkgBody::has_body() const {
  return body_case() != BODY_NOT_SET;
}
inline void SSPkgBody::clear_has_body() {
  _oneof_case_[0] = BODY_NOT_SET;
}
inline SSPkgBody::BodyCase SSPkgBody::body_case() const {
  return SSPkgBody::BodyCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SSPkg

// .SSPkgHead head = 1;
inline bool SSPkg::_internal_has_head() const {
  return this != internal_default_instance() && head_ != nullptr;
}
inline bool SSPkg::has_head() const {
  return _internal_has_head();
}
inline void SSPkg::clear_head() {
  if (GetArenaForAllocation() == nullptr && head_ != nullptr) {
    delete head_;
  }
  head_ = nullptr;
}
inline const ::SSPkgHead& SSPkg::_internal_head() const {
  const ::SSPkgHead* p = head_;
  return p != nullptr ? *p : reinterpret_cast<const ::SSPkgHead&>(
      ::_SSPkgHead_default_instance_);
}
inline const ::SSPkgHead& SSPkg::head() const {
  // @@protoc_insertion_point(field_get:SSPkg.head)
  return _internal_head();
}
inline void SSPkg::unsafe_arena_set_allocated_head(
    ::SSPkgHead* head) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(head_);
  }
  head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SSPkg.head)
}
inline ::SSPkgHead* SSPkg::release_head() {
  
  ::SSPkgHead* temp = head_;
  head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SSPkgHead* SSPkg::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:SSPkg.head)
  
  ::SSPkgHead* temp = head_;
  head_ = nullptr;
  return temp;
}
inline ::SSPkgHead* SSPkg::_internal_mutable_head() {
  
  if (head_ == nullptr) {
    auto* p = CreateMaybeMessage<::SSPkgHead>(GetArenaForAllocation());
    head_ = p;
  }
  return head_;
}
inline ::SSPkgHead* SSPkg::mutable_head() {
  ::SSPkgHead* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:SSPkg.head)
  return _msg;
}
inline void SSPkg::set_allocated_head(::SSPkgHead* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::SSPkgHead>::GetOwningArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  head_ = head;
  // @@protoc_insertion_point(field_set_allocated:SSPkg.head)
}

// .SSPkgBody body = 2;
inline bool SSPkg::_internal_has_body() const {
  return this != internal_default_instance() && body_ != nullptr;
}
inline bool SSPkg::has_body() const {
  return _internal_has_body();
}
inline void SSPkg::clear_body() {
  if (GetArenaForAllocation() == nullptr && body_ != nullptr) {
    delete body_;
  }
  body_ = nullptr;
}
inline const ::SSPkgBody& SSPkg::_internal_body() const {
  const ::SSPkgBody* p = body_;
  return p != nullptr ? *p : reinterpret_cast<const ::SSPkgBody&>(
      ::_SSPkgBody_default_instance_);
}
inline const ::SSPkgBody& SSPkg::body() const {
  // @@protoc_insertion_point(field_get:SSPkg.body)
  return _internal_body();
}
inline void SSPkg::unsafe_arena_set_allocated_body(
    ::SSPkgBody* body) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(body_);
  }
  body_ = body;
  if (body) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SSPkg.body)
}
inline ::SSPkgBody* SSPkg::release_body() {
  
  ::SSPkgBody* temp = body_;
  body_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SSPkgBody* SSPkg::unsafe_arena_release_body() {
  // @@protoc_insertion_point(field_release:SSPkg.body)
  
  ::SSPkgBody* temp = body_;
  body_ = nullptr;
  return temp;
}
inline ::SSPkgBody* SSPkg::_internal_mutable_body() {
  
  if (body_ == nullptr) {
    auto* p = CreateMaybeMessage<::SSPkgBody>(GetArenaForAllocation());
    body_ = p;
  }
  return body_;
}
inline ::SSPkgBody* SSPkg::mutable_body() {
  ::SSPkgBody* _msg = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:SSPkg.body)
  return _msg;
}
inline void SSPkg::set_allocated_body(::SSPkgBody* body) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete body_;
  }
  if (body) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::SSPkgBody>::GetOwningArena(body);
    if (message_arena != submessage_arena) {
      body = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body, submessage_arena);
    }
    
  } else {
    
  }
  body_ = body;
  // @@protoc_insertion_point(field_set_allocated:SSPkg.body)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::SSPkgHead_MSGTYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SSPkgHead_MSGTYPE>() {
  return ::SSPkgHead_MSGTYPE_descriptor();
}
template <> struct is_proto_enum< ::SSPkgHead_PROXYTYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SSPkgHead_PROXYTYPE>() {
  return ::SSPkgHead_PROXYTYPE_descriptor();
}
template <> struct is_proto_enum< ::SSPkgHead_LOGICTYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SSPkgHead_LOGICTYPE>() {
  return ::SSPkgHead_LOGICTYPE_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ss_2eproto
